<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Floor 1 - The Bits</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .game-container-wrapper {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .game-container {
            width: 100%;
            max-width: 1000px;
            text-align: center;
            margin-bottom: 1rem;
        }
        canvas {
            border: 2px solid #4f46e5;
            border-radius: 0.5rem;
            background-color: #1f2937;
            width: 100%;
            height: auto;
            max-height: 80vh;
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #1f2937;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid #4f46e5;
            color: #d1d5db;
            max-width: 95%;
            width: 600px;
            text-align: center;
        }
        /* --- Puzzle Styles --- */
        .puzzle-container { font-family: 'Roboto Mono', monospace; }
        .foreman-sprite {
            width: 64px;
            height: 64px;
            margin-right: 1rem;
            flex-shrink: 0;
        }
        .puzzle-container .power-switch {
            width: 60px; height: 60px;
            border-radius: 8px; cursor: pointer;
            border: 4px solid #374151;
            font-size: 2.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease-in-out;
        }
        .puzzle-container .power-switch.off {
            background-color: #4b5563;
            color: #be123c;
            text-shadow: none;
        }
        .puzzle-container .power-switch.on {
            background-color: #1f2937;
            color: #65a30d;
            text-shadow: 0 0 15px #a3e635;
            border-color: #65a30d;
        }
        .light {
            width: 30px; height: 30px;
            border-radius: 50%;
            background-color: #3f3f46;
            border: 4px solid #1f2937;
            transition: background-color 0.3s;
        }
        .light.on {
            background-color: #fde047;
            box-shadow: 0 0 15px #facc15;
        }
        .bit-display {
            width: 60px; height: 60px;
            font-size: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }
        .bit-value { font-size: 1.5rem; color: #9ca3af; }
        #decimal-input, #robot-name-input {
            background-color: #374151;
            border: 2px solid #4f46e5;
            color: white;
            text-align: center;
            font-size: 2rem;
            border-radius: 8px;
        }
        #decimal-input { width: 100px; }
        #robot-name-input { width: 100%; }
        #robot-canvas, #namer-robot-canvas {
            background-color: #374151;
            border-radius: 8px;
        }
        .color-switch {
            width: 40px; height: 40px;
            border-radius: 4px; cursor: pointer;
            border: 2px solid #374151;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease-in-out;
        }
        .color-switch.off { background-color: #4b5563; color: #9ca3af; }
        .color-switch.on { background-color: #65a30d; color: white; }
        #key-display { font-size: 4rem; width: 80px; height: 80px; }
        #binary-display { font-size: 2rem; letter-spacing: 2px; }
        .stairs-button {
            background-color: #4f46e5;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            border: none;
            font-weight: bold;
        }
        .stairs-button:hover { background-color: #6366f1; }
        .stairs-button.cancel { background-color: #6b7280; }
        .stairs-button.cancel:hover { background-color: #7f8794; }
    </style>
</head>
<body class="bg-gray-900">

    <div class="game-container-wrapper">
        <div class="game-container">
            <h1 class="text-3xl font-bold text-indigo-400">Assembly Floor 1: The Bits</h1>
            <p class="text-gray-400">Use Arrow Keys to move. Press 'E' to interact.</p>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="modal" class="modal-backdrop hidden">
            <div id="modal-content-area" class="modal-content">
                <!-- Content will be injected by JS -->
            </div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.querySelector('.game-container');

        // --- Asset Definitions ---
        const TILE_SIZE = 40;
        const PIXEL_SCALE = 4;
        const palette = {
            skin: '#fde68a', hair: '#4a2c2a', shirt: '#ef4444', pants: '#3b82f6',
            floor_dark: '#4b5563', floor_light: '#6b7280', platform: '#374151', platform_trim: '#4f46e5',
            station_yellow: '#facc15', station_yellow_on: '#fde047', station_green: '#4ade80', station_green_on: '#86efac', station_red: '#f87171', station_red_on: '#fca5a5', station_purple: '#c084fc', station_purple_on: '#e9d5ff',
            station_off: '#4b5563',
            foreman_hat: '#f97316', foreman_shirt: '#15803d',
            robot_gray_dark: '#6b7280', robot_gray_light: '#9ca3af', robot_eye: '#3b82f6', robot_eye_wave: '#fde047'
        };
        const playerSprite = { width: 8, height: 10, data: [ "00111100", "01111110", "00222200", "00333300", "03333330", "00333300", "00400400", "00400400", "04400440", "04400440" ], colors: [null, palette.hair, palette.skin, palette.shirt, palette.pants] };
        const powerStationSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122103030121", "122103030121", "122111111221", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_yellow, palette.station_yellow_on, palette.robot_eye] };
        const dataPostSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122133333121", "122133333121", "122133333121", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_red, palette.station_red_on, '#fff'] };
        const painterSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122134511121", "122111111121", "122111111121", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_green, palette.station_green_on, '#ef4444', '#3b82f6', '#facc15'] };
        const namerSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122131313121", "122113131321", "122131313121", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_purple, palette.station_purple_on, '#fff'] };
        const foremanSvg = `<svg class="foreman-sprite" viewBox="0 0 16 16"><path fill="${palette.skin}" d="M5,6h6v5H5V6z"/><path fill="${palette.foreman_hat}" d="M4,4h8v2H4V4z"/><path fill="${palette.foreman_shirt}" d="M4,11h8v3H4V11z"/><path fill="#000" d="M6,7h1v1H6V7zm3,0h1v1H9V7z"/></svg>`;
        
        const robotParts = {
            base:      { x: 0, y: 30, sprite: { width: 16, height: 4, data: ["1111111111111111","1222222222222221","1222222222222221","1111111111111111"], colors: [null, palette.robot_gray_dark, palette.robot_gray_light]}},
            torso:     { x: 0, y: 12, sprite: { width: 12, height: 10, data: ["001111111100","012222222210","122222222221","122222222221","122222222221","122222222221","122222222221","122222222221","012222222210","001111111100"], colors: [null, palette.robot_gray_dark, palette.robot_gray_light]}},
            head:      { x: 0, y: -10,  sprite: { width: 8, height: 8, data: ["01111110","12222221","12300321","12300321","12222221","12222221","12222221","01111110"], colors: [null, palette.robot_gray_dark, palette.robot_gray_light, palette.robot_eye]}},
            armL:      { x: -20, y: 12, sprite: { width: 4, height: 8, data: ["1110","1210","1210","1210","1210","1210","1210","1110"], colors: [null, palette.robot_gray_dark, palette.robot_gray_light]}},
            armR:      { x: 20, y: 12, sprite: { width: 4, height: 8, data: ["0111","0121","0121","0121","0121","0121","0121","0111"], colors: [null, palette.robot_gray_dark, palette.robot_gray_light]}},
            armR_wave: { x: 20, y: 8, sprite: { width: 8, height: 4, data: ["00001111","00012221","00122221","01111110",], colors: [null, palette.robot_gray_dark, palette.robot_gray_light]}},
        };
        const activationSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122133333121", "122133333121", "122111111221", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_green, palette.station_green_on, '#fff'] };

        // --- Game State ---
        const player = { x: 120, y: 50, width: playerSprite.width * PIXEL_SCALE, height: playerSprite.height * PIXEL_SCALE, speed: 4 };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let worldObjects = [];
        let centralPlatform = {};
        let isRobotWaving = false;
        let showRobotSpeechBubble = false;
        let robotName = "";
        let floorIsComplete = false;
        
        const puzzleSequence = [ 'station1', 'station3a', 'station5', 'station3b', 'station4', 'station3c', 'station6', 'station3d', 'station2', 'station7' ];
        let currentPuzzleIndex = 0;

        const puzzleState = {
            station1: { name: 'Power Systems', completed: false, target: [1, 0, 1, 1], current: [0, 0, 0, 0], text: "Let's start with the basics. We need to provide power to the assembly platform.", robotPart: 'base' },
            station2: { name: 'Robot Painter', completed: false, text: "Time for some fun! Robots see colors as numbers. Use the switches to mix Red, Green, and Blue values and give this robot a custom paint job.", R: [0,0,0,0], G: [0,0,0,0], B: [0,0,0,0], robotPart: 'torso' },
            station3a: { name: 'Data Post A', completed: false, binary: [0,0,0,1], answer: 1, text: "Each bit has a place value. This first bit on the right is the '1s' place. Since it's ON, the number is 1. Simple!", robotPart: 'none' },
            station3b: { name: 'Data Post B', completed: false, binary: [0,0,1,0], answer: 2, text: "The next bit to the left is the '2s' place. When this bit is ON and the others are OFF, the number is 2. See the pattern?", robotPart: 'none' },
            station3c: { name: 'Data Post C', completed: false, binary: [0,0,1,1], answer: 3, text: "Great! Now, what if two bits are ON? You just add their values together! The '2' bit is on, and the '1' bit is on. What is 2 + 1?", robotPart: 'none' },
            station3d: { name: 'Data Post D', completed: false, binary: [1,1,0,1], answer: 13, text: "You've got it! Now for a final check. This will install the robot's processor.", robotPart: 'head' },
            station4: { name: 'Left Arm Motor', completed: false, target: [0, 1, 1, 0], current: [0, 0, 0, 0], text: "Power up the left arm motor control unit.", robotPart: 'armL' },
            station5: { name: 'Right Arm Motor', completed: false, target: [1, 1, 0, 1], current: [0, 0, 0, 0], text: "And now power up the right arm motor control unit.", robotPart: 'armR' },
            station6: { name: 'ASCII Decoder', completed: false, text: "This is the Robot Alphabetizer! Every key you press on your keyboard sends a unique binary code. Go ahead, try typing a few letters and see their secret code!", robotPart: 'none' },
            station7: { name: 'Robot Namer', completed: false, text: "Time to give the robot a name! The robot will read its new name back to you in binary.", robotPart: 'none' },
        };

        // --- SCRIPT FOR LEVEL TRANSITION ---
        const stairsSprite = {
            width: 12, height: 10, data: [
                "000000000011", "000000000111", "000000001110", "000000011100",
                "000000111000", "000001110000", "000011100000", "000111000000",
                "001110000000", "011100000000"
            ],
            colors: [null, '#a16207']
        };
        // --- END SCRIPT FOR LEVEL TRANSITION ---

        // --- World Initialization ---
        function initializeWorld() {
            canvas.width = gameContainer.offsetWidth;
            canvas.height = window.innerHeight * 0.75;
            ctx.imageSmoothingEnabled = false;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const platformWidth = 200;
            const platformHeight = 200;

            centralPlatform = {
                type: 'platform',
                x: centerX - platformWidth / 2,
                y: centerY - platformHeight / 2,
                width: platformWidth,
                height: platformHeight
            };
            
            player.x = centerX - player.width / 2;
            player.y = centralPlatform.y + centralPlatform.height + 40;

            const stationRadiusX = (canvas.width / 2) - 80;
            const stationRadiusY = (canvas.height / 2) - 80;
            
            worldObjects = puzzleSequence.map((id, index) => {
                const angle = (2 * Math.PI / puzzleSequence.length) * index - (Math.PI / 2);
                const stationX = centerX + stationRadiusX * Math.cos(angle);
                const stationY = centerY + stationRadiusY * Math.sin(angle);
                const pz = puzzleState[id];
                let sprite;
                if (id.includes('station1') || id.includes('station4') || id.includes('station5')) sprite = powerStationSprite;
                else if (id === 'station2') sprite = painterSprite;
                else if (id.startsWith('station3')) sprite = dataPostSprite;
                else if (id === 'station6' || id === 'station7') sprite = namerSprite;

                return {
                    type: 'station', id: id, name: pz.name,
                    x: stationX - (sprite.width * PIXEL_SCALE / 2),
                    y: stationY - (sprite.height * PIXEL_SCALE / 2),
                    width: sprite.width * PIXEL_SCALE, height: sprite.height * PIXEL_SCALE,
                    sprite: sprite, onColor: sprite.colors[2], color: sprite.colors[1]
                };
            });
            
            worldObjects.push(centralPlatform);

            worldObjects.push({
                type: 'activation_station', id: 'activate', name: 'Activate',
                x: centralPlatform.x + centralPlatform.width/2 - (activationSprite.width * PIXEL_SCALE / 2),
                y: centralPlatform.y + centralPlatform.height + 10,
                width: activationSprite.width * PIXEL_SCALE,
                height: activationSprite.height * PIXEL_SCALE,
                sprite: activationSprite
            });

            // Add stairs object
            worldObjects.push({
                type: 'stairs', id: 'stairs_up', direction: 'up',
                name: 'Stairs Up', nextFloor: 'factory-floor-2.html',
                x: canvas.width - (stairsSprite.width * PIXEL_SCALE) - 20,
                y: canvas.height - (stairsSprite.height * PIXEL_SCALE) - 20,
                width: stairsSprite.width * PIXEL_SCALE,
                height: stairsSprite.height * PIXEL_SCALE,
                sprite: stairsSprite
            });
        }

        // --- Puzzle Completion Logic ---
        function completePuzzle(stationId) {
            if (puzzleState[stationId] && !puzzleState[stationId].completed) {
                puzzleState[stationId].completed = true;
                if (puzzleSequence[currentPuzzleIndex] === stationId) {
                    currentPuzzleIndex++;
                }
            }
        }

        // --- Modal & Puzzle Logic ---
        const modal = document.getElementById('modal');
        const modalContentArea = document.getElementById('modal-content-area');
        function showModal(content) { modalContentArea.innerHTML = content; modal.classList.remove('hidden'); }
        function closeModal() { modal.classList.add('hidden'); modalContentArea.innerHTML = ''; }
        function showMessage(title, text, onCloseCallback) {
            showModal(`<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left">${title}</h2><p class="text-left">${text}</p></div></div><button id="puzzle-close" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">OK</button></div>`);
            const closeButton = document.getElementById('puzzle-close');
            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    closeModal();
                    if (onCloseCallback) {
                        onCloseCallback();
                    }
                });
            }
        }

        function launchStairsModal(stair) {
            if (stair.direction === 'up' && !floorIsComplete) {
                showMessage("Wait!", "Hey, not yet. We're not done in here. Finish assembling the robot first!");
                return;
            }

            let buttonsHtml = '';
            if (stair.direction === 'up') {
                buttonsHtml += `<button class="stairs-button" onclick="window.location.href='${stair.nextFloor}'">Go Up to Floor 2</button>`;
            }
            buttonsHtml += `<button class="stairs-button cancel" onclick="closeModal()">Stay Here</button>`;

            showModal(`<div class="puzzle-container">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Stairs</h2>
                <div>${buttonsHtml}</div>
            </div>`);
        }

        function launchPowerGridPuzzle(stationId) {
            const pz = puzzleState[stationId];
            pz.current = [0, 0, 0, 0];
            const targetHtml = pz.target.map(b => `<div class="w-10 h-10 text-2xl flex items-center justify-center rounded ${b === 1 ? 'bg-green-500' : 'bg-red-500'}">${b}</div>`).join('');
            const switchesHtml = [0, 1, 2, 3].map(i => `<div class="power-switch off" data-index="${i}">0</div>`).join('');
            const lightsHtml = [0, 1, 2, 3].map(() => `<div class="light off"></div>`).join('');
            const modalHtml = `<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left text-yellow-300">${pz.name}</h2><p class="text-left">${pz.text}</p></div></div><div class="bg-black/50 p-4 rounded-lg mb-4"><h3 class="text-lg mb-2">TARGET</h3><div class="flex justify-center gap-4">${targetHtml}</div></div><div class="bg-gray-800 p-4 rounded-lg"><h3 class="text-lg mb-2">YOUR SWITCHES</h3><div id="lights-panel" class="flex justify-center gap-4 mb-4">${lightsHtml}</div><div id="switch-panel" class="flex justify-center gap-4">${switchesHtml}</div></div><div id="puzzle-feedback" class="h-6 mt-4"></div><button id="puzzle-close" class="mt-2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Exit</button></div>`;
            showModal(modalHtml);
            document.getElementById('puzzle-close').addEventListener('click', closeModal);
            document.getElementById('switch-panel').addEventListener('click', (e) => {
                const s = e.target.closest('.power-switch');
                if (s) {
                    const i = parseInt(s.dataset.index);
                    pz.current[i] = pz.current[i] === 0 ? 1 : 0;
                    updatePowerGridVisuals(stationId);
                    if (JSON.stringify(pz.current) === JSON.stringify(pz.target)) {
                        document.getElementById('puzzle-feedback').innerHTML = `<p class="text-green-400 font-bold text-xl">SUCCESS!</p>`;
                        completePuzzle(stationId);
                        setTimeout(closeModal, 1200);
                    }
                }
            });
            updatePowerGridVisuals(stationId);
        }

        function updatePowerGridVisuals(stationId) {
            const pz = puzzleState[stationId];
            document.querySelectorAll('.power-switch').forEach((s, i) => {
                const isOn = pz.current[i] === 1;
                s.classList.toggle('on', isOn);
                s.classList.toggle('off', !isOn);
                s.textContent = isOn ? '1' : '0';
            });
            document.querySelectorAll('.light').forEach((l, i) => l.classList.toggle('on', pz.current[i] === 1));
        }

        function launchDataPostPuzzle(stationId) {
            const pz = puzzleState[stationId];
            const placeValues = [8, 4, 2, 1];
            const binaryHtml = pz.binary.map((bit, i) => `<div class="flex flex-col items-center"><div class="bit-display ${bit === 1 ? 'bg-blue-500' : 'bg-gray-700'}">${bit}</div><div class="bit-value mt-2">${placeValues[i]}</div></div>`).join('');
            const modalHtml = `<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left text-red-400">${pz.name}</h2><p class="text-left">${pz.text}</p></div></div><div class="bg-black/50 p-4 rounded-lg mb-4"><h3 class="text-lg mb-2">BINARY VALUE</h3><div class="flex justify-center gap-4">${binaryHtml}</div></div><div class="bg-gray-800 p-4 rounded-lg flex flex-col items-center"><h3 class="text-lg mb-2">ENTER DECIMAL TOTAL</h3><input id="decimal-input" type="number" /><button id="submit-answer" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Submit</button></div><div id="puzzle-feedback" class="h-6 mt-4"></div><button id="puzzle-close" class="mt-2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Exit</button></div>`;
            showModal(modalHtml);
            document.getElementById('puzzle-close').addEventListener('click', closeModal);
            document.getElementById('submit-answer').addEventListener('click', () => {
                const inputVal = document.getElementById('decimal-input').value;
                if (parseInt(inputVal) === pz.answer) {
                    document.getElementById('puzzle-feedback').innerHTML = `<p class="text-green-400 font-bold text-xl">CORRECT!</p>`;
                    completePuzzle(stationId);
                    setTimeout(closeModal, 1500);
                } else {
                    document.getElementById('puzzle-feedback').innerHTML = `<p class="text-red-400 font-bold">Not quite. Try adding the values again.</p>`;
                }
            });
        }

        function launchRobotPainterPuzzle() {
            const pz = puzzleState.station2;
            const createColorSwitches = (color) => [0,1,2,3].map(i => `<div class="color-switch ${pz[color][i] ? 'on' : 'off'}" data-color="${color}" data-index="${i}">${pz[color][i]}</div>`).join('');
            const modalHtml = `<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left text-green-400">${pz.name}</h2><p class="text-left">${pz.text}</p></div></div><div class="flex flex-col md:flex-row gap-4"><canvas id="robot-canvas" width="200" height="250"></canvas><div class="flex-grow"><div class="mb-2"><p class="text-red-500 font-bold">RED</p><div class="flex justify-around p-2 bg-gray-800 rounded">${createColorSwitches('R')}</div></div><div class="mb-2"><p class="text-green-500 font-bold">GREEN</p><div class="flex justify-around p-2 bg-gray-800 rounded">${createColorSwitches('G')}</div></div><div class="mb-2"><p class="text-blue-500 font-bold">BLUE</p><div class="flex justify-around p-2 bg-gray-800 rounded">${createColorSwitches('B')}</div></div></div></div><button id="puzzle-close" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Save Colors & Exit</button></div>`;
            showModal(modalHtml);
            const robotCanvasCtx = document.getElementById('robot-canvas').getContext('2d');
            robotCanvasCtx.imageSmoothingEnabled = false;
            function drawRobot() {
                const binToDec = arr => arr.reduce((acc, val, i) => acc + val * [8,4,2,1][i], 0);
                const r = binToDec(pz.R) * 17, g = binToDec(pz.G) * 17, b = binToDec(pz.B) * 17;
                robotParts.torso.sprite.colors[2] = `rgb(${r},${g},${b})`;
                robotCanvasCtx.clearRect(0, 0, 200, 250);
                const scale = 4;
                const canvasCenterX = robotCanvasCtx.canvas.width / 2;
                const canvasCenterY = robotCanvasCtx.canvas.height / 2;
                Object.values(robotParts).forEach(part => {
                    if (part.sprite) drawSpriteOnOtherCanvas(robotCanvasCtx, part.sprite, canvasCenterX + part.x - (part.sprite.width * scale / 2), canvasCenterY + part.y - (part.sprite.height * scale / 2), scale);
                });
            }
            drawRobot();
            document.querySelectorAll('.color-switch').forEach(s => s.addEventListener('click', () => {
                s.classList.toggle('on'); s.classList.toggle('off');
                const color = s.dataset.color, index = parseInt(s.dataset.index), isOn = s.classList.contains('on');
                pz[color][index] = isOn ? 1 : 0;
                s.textContent = isOn ? '1' : '0';
                drawRobot();
            }));
            document.getElementById('puzzle-close').addEventListener('click', () => { completePuzzle('station2'); closeModal(); });
        }
        
        function launchAsciiDecoderPuzzle() {
            const pz = puzzleState.station6;
            const modalHtml = `<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left text-purple-400">${pz.name}</h2><p class="text-left">${pz.text}</p></div></div><div class="bg-black/50 p-4 rounded-lg flex justify-around items-center"><div id="key-display" class="bg-gray-700 rounded-lg flex items-center justify-center text-gray-500">?</div><div id="binary-display" class="text-purple-400">00000000</div></div><p class="mt-4">Click here and start typing!</p><button id="puzzle-close" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">I get it!</button></div>`;
            showModal(modalHtml);
            const keyDisplay = document.getElementById('key-display'), binaryDisplay = document.getElementById('binary-display');
            const keyHandler = (e) => {
                if (e.key.length === 1) {
                    keyDisplay.textContent = e.key.toUpperCase();
                    keyDisplay.classList.remove('text-gray-500');
                    binaryDisplay.textContent = e.key.charCodeAt(0).toString(2).padStart(8, '0');
                }
            };
            document.addEventListener('keydown', keyHandler);
            document.getElementById('puzzle-close').addEventListener('click', () => {
                document.removeEventListener('keydown', keyHandler);
                completePuzzle('station6');
                closeModal();
            });
        }

        function launchRobotNamerPuzzle() {
            const pz = puzzleState.station7;
            const modalHtml = `<div class="puzzle-container"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left text-purple-400">${pz.name}</h2><p class="text-left">${pz.text}</p></div></div><div class="flex flex-col md:flex-row gap-4"><canvas id="namer-robot-canvas" width="150" height="250"></canvas><div class="flex-grow"><div class="bg-black/50 p-4 rounded-lg h-full flex flex-col justify-between"><input id="robot-name-input" type="text" placeholder="Type name here..." maxlength="8" /><button id="submit-name" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Name Robot</button><div id="robot-response" class="h-20 mt-4 p-2 bg-gray-800 rounded text-left overflow-y-auto text-sm"></div></div></div></div><button id="puzzle-close" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Done</button></div>`;
            showModal(modalHtml);
            const robotCanvasCtx = document.getElementById('namer-robot-canvas').getContext('2d');
            robotCanvasCtx.imageSmoothingEnabled = false;
            const scale = 4;
            const canvasCenterX = robotCanvasCtx.canvas.width / 2;
            const canvasCenterY = robotCanvasCtx.canvas.height / 2;
            Object.values(robotParts).forEach(part => {
                if(part.sprite) drawSpriteOnOtherCanvas(robotCanvasCtx, part.sprite, canvasCenterX + part.x - (part.sprite.width * scale / 2), canvasCenterY + part.y - (part.sprite.height * scale / 2), scale);
            });
            document.getElementById('submit-name').addEventListener('click', () => {
                const nameInput = document.getElementById('robot-name-input');
                const responseBox = document.getElementById('robot-response');
                if (nameInput.value) {
                    robotName = nameInput.value;
                    let binaryName = '';
                    for (let i = 0; i < nameInput.value.length; i++) binaryName += nameInput.value[i].charCodeAt(0).toString(2).padStart(8, '0') + ' ';
                    responseBox.innerHTML = `<p class="text-green-400">> Thank you! My name is:</p><p>${binaryName}</p>`;
                    completePuzzle('station7');
                    robotParts.head.sprite.colors[3] = palette.robot_eye_wave;
                } else {
                    responseBox.innerHTML = `<p class="text-red-400">> Please enter a name first!</p>`;
                }
            });
            document.getElementById('puzzle-close').addEventListener('click', closeModal);
        }

        // --- Drawing & Collision ---
        function checkCollision(r1, r2) {
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r1.height > r2.y;
        }

        function drawSprite(sprite, x, y, scale, baseColor) {
            const colors = [...sprite.colors];
            if (baseColor) colors[1] = baseColor;
            for (let r = 0; r < sprite.height; r++) {
                for (let col = 0; col < sprite.width; col++) {
                    const index = parseInt(sprite.data[r][col]);
                    if (index !== 0 && colors[index]) {
                        ctx.fillStyle = colors[index];
                        ctx.fillRect(x + col * scale, y + r * scale, scale, scale);
                    }
                }
            }
        }
        
        function drawSpriteOnOtherCanvas(canvasContext, sprite, x, y, scale) {
            for (let r = 0; r < sprite.height; r++) {
                for (let col = 0; col < sprite.width; col++) {
                    const index = parseInt(sprite.data[r][col]);
                    if (index !== 0 && sprite.colors[index]) {
                        canvasContext.fillStyle = sprite.colors[index];
                        canvasContext.fillRect(x + col * scale, y + r * scale, scale, scale);
                    }
                }
            }
        }

        function drawWorld() {
            // Floor
            for (let y = 0; y < canvas.height; y += TILE_SIZE) for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                ctx.fillStyle = ((x + y) / TILE_SIZE) % 2 === 0 ? palette.floor_dark : palette.floor_light;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
            // Central Platform
            ctx.fillStyle = palette.platform;
            ctx.fillRect(centralPlatform.x, centralPlatform.y, centralPlatform.width, centralPlatform.height);
            ctx.strokeStyle = palette.platform_trim;
            ctx.lineWidth = 4;
            ctx.strokeRect(centralPlatform.x, centralPlatform.y, centralPlatform.width, centralPlatform.height);

            // Spotlight for active station
            const allPuzzlesComplete = currentPuzzleIndex >= puzzleSequence.length;
            if (!allPuzzlesComplete) {
                const activeStationId = puzzleSequence[currentPuzzleIndex];
                const activeStation = worldObjects.find(obj => obj.id === activeStationId);
                if (activeStation) {
                    ctx.fillStyle = 'rgba(253, 224, 71, 0.3)';
                    ctx.beginPath();
                    ctx.arc(activeStation.x + activeStation.width / 2, activeStation.y + activeStation.height / 2, 60, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Stations and other objects
            worldObjects.forEach(obj => {
                if (obj.type === 'station') {
                    const isCompleted = puzzleState[obj.id].completed;
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE, isCompleted ? obj.onColor : obj.color);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                } else if (obj.type === 'activation_station' && allPuzzlesComplete) {
                     drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE, isRobotWaving ? obj.sprite.colors[2] : obj.sprite.colors[1]);
                     ctx.fillStyle = '#ffffff';
                     ctx.font = '12px "Roboto Mono"';
                     ctx.textAlign = 'center';
                     ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                } else if (obj.type === 'stairs') {
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE);
                    ctx.fillStyle = floorIsComplete ? '#a3e635' : '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                }
            });
            
            // Robot Drawing Logic
            const robotCenterX = centralPlatform.x + centralPlatform.width / 2;
            const robotCenterY = centralPlatform.y + centralPlatform.height / 2;
            const robotScale = 5;
            const partsToDraw = [];
            Object.values(puzzleState).forEach(pz => {
                if (pz.completed && pz.robotPart !== 'none') {
                    partsToDraw.push(pz.robotPart);
                }
            });
            partsToDraw.forEach(partName => {
                if (partName === 'armR' && isRobotWaving) {
                    const wavePart = robotParts.armR_wave;
                    drawSprite(wavePart.sprite, robotCenterX + wavePart.x - (wavePart.sprite.width * robotScale / 2), robotCenterY + wavePart.y - (wavePart.sprite.height * robotScale / 2), robotScale);
                } else {
                    const part = robotParts[partName];
                    if (part) {
                        drawSprite(part.sprite, robotCenterX + part.x - (part.sprite.width * robotScale / 2), robotCenterY + part.y - (part.sprite.height * robotScale / 2), robotScale);
                    }
                }
            });

            // Speech Bubble Logic
            if (showRobotSpeechBubble && robotName) {
                const headPart = robotParts.head;
                const headX = robotCenterX + headPart.x - (headPart.sprite.width * robotScale / 2);
                const headY = robotCenterY + headPart.y - (headPart.sprite.height * robotScale / 2);

                let binaryName = '';
                for (let i = 0; i < robotName.length; i++) {
                    binaryName += robotName[i].charCodeAt(0).toString(2).padStart(8, '0') + ' ';
                }
                const bubbleText = `Hi, my name is ${binaryName.trim()}`;

                ctx.font = '14px "Roboto Mono"';
                const textMetrics = ctx.measureText(bubbleText);
                const bubbleWidth = textMetrics.width + 20;
                const bubbleHeight = 35;
                const bubbleX = headX - bubbleWidth / 2 + (headPart.sprite.width * robotScale / 2);
                const bubbleY = headY - bubbleHeight - 15;

                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 10);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(bubbleX + bubbleWidth / 2 - 5, bubbleY + bubbleHeight -1);
                ctx.lineTo(bubbleX + bubbleWidth / 2 + 5, bubbleY + bubbleHeight -1);
                ctx.lineTo(headX + (headPart.sprite.width * robotScale / 2), headY);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(bubbleText, bubbleX + bubbleWidth / 2, bubbleY + bubbleHeight / 2);
                ctx.textBaseline = 'alphabetic';
                ctx.textAlign = 'start';
            }
        }

        // --- Game Loop ---
        function update() {
            let nextX = player.x, nextY = player.y;
            if (keys.ArrowUp) nextY -= player.speed;
            if (keys.ArrowDown) nextY += player.speed;
            if (keys.ArrowLeft) nextX -= player.speed;
            if (keys.ArrowRight) nextX += player.speed;

            if (nextX < 0) nextX = 0;
            if (nextX + player.width > canvas.width) nextX = canvas.width - player.width;
            if (nextY < 0) nextY = 0;
            if (nextY + player.height > canvas.height) nextY = canvas.height - player.height;

            let isColliding = false;
            for (const obj of worldObjects) {
                if (obj.type === 'platform' && checkCollision({ ...player, x: nextX, y: nextY }, obj)) {
                    isColliding = true;
                    break;
                }
            }

            if (!isColliding) {
                player.x = nextX;
                player.y = nextY;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            drawSprite(playerSprite, player.x, player.y, PIXEL_SCALE);
            
            const allPuzzlesComplete = currentPuzzleIndex >= puzzleSequence.length;
            let interactionTarget = worldObjects.find(obj => {
                if (obj.type === 'platform') return false;
                if (obj.type === 'activation_station' && !allPuzzlesComplete) return false;
                return checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 });
            });
            
            if (interactionTarget) {
                ctx.fillStyle = 'white';
                ctx.font = '16px "Inter"';
                ctx.textAlign = 'center';
                ctx.fillText(`Press 'E' to interact with ${interactionTarget.name}`, canvas.width / 2, canvas.height - 30);
            }
        }

        function gameLoop() {
            if (modal.classList.contains('hidden')) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        function handleInteraction(obj) {
            if (obj.type === 'stairs') {
                launchStairsModal(obj);
                return;
            }

            const activeStationId = puzzleSequence[currentPuzzleIndex];
            const allPuzzlesComplete = currentPuzzleIndex >= puzzleSequence.length;

            if (obj.id === 'activate') {
                if (allPuzzlesComplete && !isRobotWaving) {
                    isRobotWaving = true;
                    showRobotSpeechBubble = true;
                    floorIsComplete = true; // Activate stairs
                    setTimeout(() => { 
                        isRobotWaving = false; 
                        showRobotSpeechBubble = false;
                    }, 3000); // Let animation play
                }
                return;
            }

            if (obj.id !== activeStationId) {
                showMessage('Out of Sequence', 'This station is not active. Please find the highlighted station to proceed.');
                return;
            }

             if (obj.id.startsWith('station1') || obj.id.startsWith('station4') || obj.id.startsWith('station5')) { launchPowerGridPuzzle(obj.id); }
             else if (obj.id === 'station2') { launchRobotPainterPuzzle(); }
             else if (obj.id.startsWith('station3')) { launchDataPostPuzzle(obj.id); }
             else if (obj.id === 'station6') { launchAsciiDecoderPuzzle(); }
             else if (obj.id === 'station7') { launchRobotNamerPuzzle(); }
        }
        
        window.addEventListener('keydown', (e) => {
            if (modal.classList.contains('hidden')) {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'e') {
                    const allPuzzlesComplete = currentPuzzleIndex >= puzzleSequence.length;
                    const interactionTarget = worldObjects.find(obj => {
                        if (obj.type === 'platform') return false;
                        if (obj.type === 'activation_station' && !allPuzzlesComplete) return false;
                        return checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 });
                    });
                    if (interactionTarget) {
                        handleInteraction(interactionTarget);
                    }
                }
            }
        });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        
        window.addEventListener('resize', initializeWorld);

        // --- Start the game! ---
        function startGame() {
            initializeWorld();
            const introTitle = "Welcome to the Factory!";
            const introText = "This is the first floor. You'll start by helping us with binary. That's the language of computers and robots! Follow the spotlight to the first active station to begin.";
            showMessage(introTitle, introText, gameLoop);
        }

        startGame();
    </script>
</body>
</html>


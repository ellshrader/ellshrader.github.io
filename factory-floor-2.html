<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Floor 2 - Gates & Transistors</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
            overflow: hidden;
            image-rendering: pixelated;
        }
        .game-container-wrapper {
            width: 100%; height: 100vh; display: flex; flex-direction: column;
            align-items: center; justify-content: center; padding: 1rem;
        }
        .game-container {
            width: 100%; max-width: 1000px; text-align: center; margin-bottom: 1rem;
        }
        canvas {
            border: 2px solid #be185d; border-radius: 0.5rem; background-color: #1f2937;
            width: 100%; height: auto; max-height: 80vh;
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background-color: #1f2937; padding: 1.5rem; border-radius: 0.5rem;
            border: 1px solid #be185d; color: #d1d5db; max-width: 95%;
            width: 900px; text-align: center;
        }
        .circuit-bg { background-color: #1e293b; }
        .bit-display {
            width: 80px; height: 80px; border-radius: 0.5rem; border: 4px solid #475569;
            font-family: 'Roboto Mono', monospace; font-size: 2.5rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .bit-display.input.off, .bit-display.output.off { background-color: #475569; color: #f43f5e; }
        .bit-display.input.on { background-color: #1e293b; color: #4ade80; border-color: #4ade80; }
        .bit-display.output.on { background-color: #1e293b; color: #4ade80; border-color: #4ade80; }
        .circuit-line { stroke: #475569; stroke-width: 8; stroke-linecap: round; transition: stroke 0.3s; }
        .circuit-line.control-powered { stroke: #4ade80; }
        .circuit-line.main-powered { stroke: #facc15; }
        .circuit-text { font-family: 'Roboto Mono', monospace; fill: #94a3b8; font-size: 14px; }
        .light-bulb-glass { fill: #475569; transition: all 0.3s; }
        .light-bulb-glass.on { fill: #fde047; filter: drop-shadow(0 0 8px #fde047); }
        .light-bulb-base { fill: #64748b; }
        .transistor-box { fill: #334155; stroke: #be185d; stroke-width: 2; transition: all 0.3s; }
        .transistor-box.active { fill: #166534; filter: drop-shadow(0 0 8px #4ade80); }
        .transistor-text { fill: #be185d; font-weight: bold; font-size: 24px; }
        .draggable-part { cursor: grab; }
        .draggable-part.dragging { cursor: grabbing; transform: scale(1.1); opacity: 0.7; position: absolute; z-index: 1000; }
        .drop-zone { fill: rgba(139, 92, 246, 0.4); stroke: #a78bfa; stroke-width: 2; stroke-dasharray: 4; transition: fill 0.2s; }
        .placed-gate-bg { fill: #1e293b; }
        .gate-symbol { stroke: #cbd5e1; stroke-width: 6; fill: none; }
        .gate-label {
            font-family: 'Roboto Mono', monospace;
            fill: #e5e7eb;
            font-size: 18px;
            font-weight: bold;
            text-anchor: middle;
            user-select: none;
        }
        .truth-table th, .truth-table td {
            border: 1px solid #475569; padding: 0.5rem 1rem; text-align: center;
            font-family: 'Roboto Mono', monospace; color: #cbd5e1; font-size: 1.125rem;
        }
        .truth-table th { background-color: #334155; }
        .truth-table tr.discovered { color: #86efac; font-weight: bold; }
        .gate-id-bit {
            font-family: 'Roboto Mono', monospace;
            font-size: 24px;
            font-weight: bold;
            transition: fill 0.2s ease-in-out;
        }
        .gate-id-bit.off { fill: #f43f5e; }
        .gate-id-bit.on { fill: #4ade80; }
        .stairs-button {
            background-color: #be185d;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            border: none;
            font-weight: bold;
        }
        .stairs-button:hover { background-color: #db2777; }
        .stairs-button.cancel { background-color: #6b7280; }
        .stairs-button.cancel:hover { background-color: #7f8794; }
    </style>
</head>
<body class="bg-slate-900">

    <div class="game-container-wrapper">
        <div class="game-container">
            <h1 class="text-3xl font-bold text-pink-500">Assembly Floor 2: Gates & Transistors</h1>
            <p class="text-gray-400">Use Arrow Keys to move. Press 'E' to interact.</p>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="modal" class="modal-backdrop hidden">
            <div id="modal-content-area" class="modal-content"></div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let puzzleInterval;

        // --- Asset Definitions ---
        const TILE_SIZE = 40;
        const PIXEL_SCALE = 4;
        const palette = {
            skin: '#fde68a', hair: '#4a2c2a', shirt: '#ef4444', pants: '#3b82f6',
            floor_dark: '#581c87', floor_light: '#6d28d9', platform: '#374151', platform_trim: '#be185d',
            station_purple: '#a855f7', station_purple_on: '#c084fc',
            station_blue: '#3b82f6', station_blue_on: '#60a5fa', station_cyan: '#06b6d4', station_cyan_on: '#22d3ee',
            station_orange: '#f97316', station_orange_on: '#fb923c', station_teal: '#0d9488', station_teal_on: '#2dd4bf',
            foreman_hat: '#f97316', foreman_shirt: '#15803d',
        };
        const playerSprite = { width: 8, height: 10, data: ["00111100","01111110","00222200","00333300","03333330","00333300","00400400","00400400","04400440","04400440"], colors: [null, palette.hair, palette.skin, palette.shirt, palette.pants] };
        const foremanSvg = `<svg class="foreman-sprite" viewBox="0 0 16 16"><path fill="${palette.skin}" d="M5,6h6v5H5V6z"/><path fill="${palette.foreman_hat}" d="M4,4h8v2H4V4z"/><path fill="${palette.foreman_shirt}" d="M4,11h8v3H4V11z"/><path fill="#000" d="M6,7h1v1H6V7zm3,0h1v1H9V7z"/></svg>`;
        const transistorStationSprite = { width: 12, height: 10, data: ["001111111100","012222222210","122222222221","122111111221","122131113121","122113131121","122111311121","122222222221","012222222210","001111111100"], colors: [null, palette.station_purple, palette.station_purple_on, '#fff'] };
        const notGateSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122103300121", "122103030121", "122111111221", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_blue, palette.station_blue_on, '#fff'] };
        const andGateSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122111111221", "122130030121", "122130030121", "122133330121", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_cyan, palette.station_cyan_on, '#fff'] };
        const orGateSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122222222221", "122101110121", "122130103121", "122130103121", "122133033121", "122222222221", "012222222210", "001111111100" ], colors: [null, palette.station_orange, palette.station_orange_on, '#fff'] };
        const gateIdSprite = { width: 12, height: 10, data: [ "001111111100", "012222222210", "122122222221", "121101110121", "113130103111", "113130103111", "121133033121", "122122222221", "012222222210", "001111111100" ], colors: [null, palette.station_teal, palette.station_teal_on, '#fff'] };

        // --- Game State ---
        const player = { x: 120, y: 50, width: playerSprite.width * PIXEL_SCALE, height: playerSprite.height * PIXEL_SCALE, speed: 4 };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let worldObjects = [];
        let centralPlatform = {};
        const puzzleSequence = ['transistor_basics', 'not_gate', 'and_gate', 'or_gate', 'gate_identification'];
        let currentPuzzleIndex = 0;
        let floorIsComplete = false;
        const puzzleState = {
            'transistor_basics': { name: 'Transistor Basics', completed: false, title: 'The Transistor Switch', text: "A transistor acts like a gate. When the <span class='text-green-400'>Control Signal</span> is ON, the gate activates, allowing the <span class='text-yellow-400'>Main Power</span> to flow through." },
            'not_gate': { name: 'NOT Gate', completed: false, symbol: 'not', title: 'The NOT Gate', buildText: "A NOT gate inverts the input. To build one, drag the transistor into the empty slot. It's wired to divert power away from the bulb to Ground (GND).", testText: "Flip the switch! When the input is ON (1), the transistor activates and diverts power, turning the output OFF (0). This is inversion!" },
            'and_gate': { name: 'AND Gate', completed: false, symbol: 'and', title: 'The AND Gate', buildText: "An AND gate requires both inputs to be ON. Build it by placing two transistors in a row (in series).", testText: "Test it out! You'll see that both Input A AND Input B must be ON (1) to complete the circuit and turn the light on." },
            'or_gate': { name: 'OR Gate', completed: false, symbol: 'or', title: 'The OR Gate', buildText: "An OR gate requires at least one input to be ON. Build it by placing two transistors in parallel paths.", testText: "Give it a try! If Input A OR Input B is ON (1), the power has a path to flow to the light." },
            'gate_identification': { name: 'Gate ID', completed: false, title: 'Gate Identification', text: "You've seen how to build the basic gates. Now, prove you know them when you see them! Watch the circuits and drag the correct gate symbol onto each one." },
        };

        // --- SCRIPT FOR LEVEL TRANSITION ---
        const stairsSprite = {
            width: 12, height: 10, data: [
                "000000000011", "000000000111", "000000001110", "000000011100",
                "000000111000", "000001110000", "000011100000", "000111000000",
                "001110000000", "011100000000"
            ],
            colors: [null, '#a16207']
        };
        // --- END SCRIPT FOR LEVEL TRANSITION ---

        // --- World Initialization ---
        function initializeWorld() {
            const gameContainer = document.querySelector('.game-container');
            canvas.width = gameContainer.offsetWidth;
            canvas.height = window.innerHeight * 0.75;
            ctx.imageSmoothingEnabled = false;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            centralPlatform = { 
                type: 'platform', 
                x: centerX - 125, y: centerY - 75, 
                width: 250, height: 150,
                collectedSymbols: centralPlatform.collectedSymbols || []
            };
            player.x = centerX - player.width / 2;
            player.y = centralPlatform.y + centralPlatform.height + 40;

            const stationRadiusX = (canvas.width / 2) - 100;
            const stationRadiusY = (canvas.height / 2) - 100;
            const stationSprites = { 'transistor_basics': transistorStationSprite, 'not_gate': notGateSprite, 'and_gate': andGateSprite, 'or_gate': orGateSprite, 'gate_identification': gateIdSprite };

            worldObjects = puzzleSequence.map((id, index) => {
                const angle = (2 * Math.PI / puzzleSequence.length) * index - (Math.PI / 2);
                const stationX = centerX + stationRadiusX * Math.cos(angle);
                const stationY = centerY + stationRadiusY * Math.sin(angle);
                const sprite = stationSprites[id];
                return {
                    type: 'station', id, name: puzzleState[id].name,
                    x: stationX - (sprite.width * PIXEL_SCALE / 2), y: stationY - (sprite.height * PIXEL_SCALE / 2),
                    width: sprite.width * PIXEL_SCALE, height: sprite.height * PIXEL_SCALE,
                    sprite: sprite, onColor: sprite.colors[2], color: sprite.colors[1]
                };
            });
            worldObjects.push(centralPlatform);

            // Add stairs objects
            worldObjects.push({
                type: 'stairs', id: 'stairs_up', direction: 'up',
                name: 'Stairs Up', nextFloor: 'factory-floor-3.html',
                x: canvas.width - (stairsSprite.width * PIXEL_SCALE) - 20,
                y: canvas.height - (stairsSprite.height * PIXEL_SCALE) - 20,
                width: stairsSprite.width * PIXEL_SCALE, height: stairsSprite.height * PIXEL_SCALE,
                sprite: stairsSprite
            });
            worldObjects.push({
                type: 'stairs', id: 'stairs_down', direction: 'down',
                name: 'Stairs Down', nextFloor: 'factory-floor-1.html',
                x: 20,
                y: canvas.height - (stairsSprite.height * PIXEL_SCALE) - 20,
                width: stairsSprite.width * PIXEL_SCALE, height: stairsSprite.height * PIXEL_SCALE,
                sprite: stairsSprite
            });
        }

        // --- Modal & Puzzle Logic ---
        const modal = document.getElementById('modal');
        const modalContentArea = document.getElementById('modal-content-area');
        function showModal(content) { modalContentArea.innerHTML = content; modal.classList.remove('hidden'); }
        function closeModal() {
            if (puzzleInterval) {
                clearInterval(puzzleInterval);
                puzzleInterval = null;
            }
            modal.classList.add('hidden');
            modalContentArea.innerHTML = '';
        }
        function showMessage(title, text, onCloseCallback) {
            showModal(`<div class="p-4"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left">${title}</h2><p class="text-left">${text}</p></div></div><button id="puzzle-close" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">OK</button></div>`);
            document.getElementById('puzzle-close').addEventListener('click', () => { closeModal(); if (onCloseCallback) onCloseCallback(); });
        }
        
        function launchStairsModal(stair) {
            if (stair.direction === 'up' && !floorIsComplete) {
                showMessage("Wait!", "Hey, not yet. We're not done in here. Finish learning about these gates first!");
                return;
            }

            let buttonsHtml = '';
            if (stair.direction === 'up') {
                buttonsHtml += `<button class="stairs-button" onclick="window.location.href='${stair.nextFloor}'">Go Up to Floor 3</button>`;
            }
            if (stair.direction === 'down') {
                buttonsHtml += `<button class="stairs-button" onclick="window.location.href='${stair.nextFloor}'">Go Down to Floor 1</button>`;
            }
            buttonsHtml += `<button class="stairs-button cancel" onclick="closeModal()">Stay Here</button>`;

            showModal(`<div class="puzzle-container">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Stairs</h2>
                <div>${buttonsHtml}</div>
            </div>`);
        }

        function completePuzzle(stationId) {
            const pz = puzzleState[stationId];
            if (pz && !pz.completed) {
                pz.completed = true;
                if (puzzleSequence[currentPuzzleIndex] === stationId) {
                    currentPuzzleIndex++;
                }
                if (pz.symbol && !centralPlatform.collectedSymbols.includes(pz.symbol)) {
                    centralPlatform.collectedSymbols.push(pz.symbol);
                }
            }
            if (currentPuzzleIndex >= puzzleSequence.length && !floorIsComplete) {
                floorIsComplete = true;
                setTimeout(() => {
                    showMessage("Floor Complete!", "Excellent work! You now know how logic gates are built and what they do. The stairs to the repair bay are now open!");
                }, 500);
            }
        }

        // --- Puzzle Templates ---
        const schematics = {
            transistor_basics: `<svg viewBox="0 0 400 150" class="w-full"><g><rect x="5" y="75" width="40" height="60" rx="5" fill="#334155" /><rect x="15" y="70" width="20" height="5" fill="#facc15" /><text x="50" y="125" class="circuit-text">Main Power</text></g><path d="M45 105 H 150" class="circuit-line main-powered" /><path id="power-out" d="M250 105 H 300" class="circuit-line" /><path id="control-line" d="M-50 40 H 200" class="circuit-line" /><g transform="translate(150, 70)"><rect id="transistor-box" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text><path d="M50 -30 V 0" class="circuit-line" id="control-pin" /><path d="M0 35 H -20" class="circuit-line main-powered" /><path id="output-pin" d="M100 35 H 120" class="circuit-line" /></g><g transform="translate(320, 80)"><path d="M-15 25 h30 v5 h-30 z" class="light-bulb-base" /><path class="light-bulb-glass" id="light-bulb" d="M-20 0 a20,20 0 1,1 40,0" /><path d="M-10 25 v-10 h20 v10" class="light-bulb-base" /></g></svg>`,
            not_gate: `<svg viewBox="0 0 400 180" class="w-full"><g><rect x="5" y="90" width="40" height="60" rx="5" fill="#334155" /><rect x="15" y="85" width="20" height="5" fill="#facc15" /><text x="50" y="140" class="circuit-text">Main Power</text></g><path d="M45 120 H 150" class="circuit-line main-powered" /><path id="power-to-bulb" d="M150 120 H 260" class="circuit-line" /><path id="control-line" d="M-50 55 H 200" class="circuit-line" /><g id="transistor-group" transform="translate(150, 85)"><rect id="drop-zone-0" class="drop-zone" data-type="transistor" width="100" height="70" rx="5" /><g id="placed-transistor-0" style="visibility: hidden;"><rect id="transistor-box-0" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text></g></g><path id="control-pin-0" d="M200 55 V 85" class="circuit-line" /><path id="diverter-pin-0" d="M200 155 V 175" class="circuit-line" /><text x="210" y="178" class="circuit-text" font-size="12">GND</text><g transform="translate(280, 95)"><path d="M-15 25 h30 v5 h-30 z" class="light-bulb-base" /><path class="light-bulb-glass" id="light-bulb" d="M-20 0 a20,20 0 1,1 40,0" /><path d="M-10 25 v-10 h20 v10" class="light-bulb-base" /></g></svg>`,
            and_gate: `<svg viewBox="0 0 450 180" class="w-full"><g><rect x="5" y="90" width="40" height="60" rx="5" fill="#334155" /><rect x="15" y="85" width="20" height="5" fill="#facc15" /><text x="50" y="140" class="circuit-text">Main Power</text></g><path d="M45 120 H 100" class="circuit-line main-powered" /><path id="power-mid" d="M200 120 H 250" class="circuit-line" /><path id="power-out" d="M350 120 H 400" class="circuit-line" /><path id="control-line-A" d="M-100 25 H 150" class="circuit-line" /><path id="control-line-B" d="M-100 55 H 300" class="circuit-line" /><g transform="translate(100, 85)"><rect id="drop-zone-0" class="drop-zone" data-type="transistor" width="100" height="70" rx="5" /><g id="placed-transistor-0" style="visibility: hidden;"><rect id="transistor-box-0" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text></g></g><g transform="translate(250, 85)"><rect id="drop-zone-1" class="drop-zone" data-type="transistor" width="100" height="70" rx="5" /><g id="placed-transistor-1" style="visibility: hidden;"><rect id="transistor-box-1" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text></g></g><path id="control-pin-0" d="M150 25 V 85" class="circuit-line" /><path id="control-pin-1" d="M300 55 V 85" class="circuit-line" /><g transform="translate(420, 95)"><path d="M-15 25 h30 v5 h-30 z" class="light-bulb-base" /><path class="light-bulb-glass" id="light-bulb" d="M-20 0 a20,20 0 1,1 40,0" /><path d="M-10 25 v-10 h20 v10" class="light-bulb-base" /></g></svg>`,
            or_gate: `<svg viewBox="0 0 450 220" class="w-full"><g><rect x="5" y="90" width="40" height="60" rx="5" fill="#334155" /><rect x="15" y="85" width="20" height="5" fill="#facc15" /><text x="50" y="140" class="circuit-text">Main Power</text></g><path d="M45 120 H 100" class="circuit-line main-powered" /><path id="power-top-in" d="M100 120 V 55 H 150" class="circuit-line main-powered" /><path id="power-bottom-in" d="M100 120 V 185 H 150" class="circuit-line main-powered" /><path id="power-top-out" d="M250 55 H 300 V 120" class="circuit-line" /><path id="power-bottom-out" d="M250 185 H 300 V 120" class="circuit-line" /><path id="power-final" d="M300 120 H 350" class="circuit-line" /><path id="control-line-A" d="M-100 25 H 200" class="circuit-line" /><path id="control-line-B" d="M-100 215 H 200" class="circuit-line" /><g transform="translate(150, 20)"><rect id="drop-zone-0" class="drop-zone" data-type="transistor" width="100" height="70" rx="5" /><g id="placed-transistor-0" style="visibility: hidden;"><rect id="transistor-box-0" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text></g></g><g transform="translate(150, 150)"><rect id="drop-zone-1" class="drop-zone" data-type="transistor" width="100" height="70" rx="5" /><g id="placed-transistor-1" style="visibility: hidden;"><rect id="transistor-box-1" class="transistor-box" width="100" height="70" rx="5" /><text class="transistor-text" x="50" y="42" text-anchor="middle">T</text></g></g><path id="control-pin-0" d="M200 25 V 20" class="circuit-line" /><path id="control-pin-1" d="M200 215 V 220" class="circuit-line" /><g transform="translate(370, 95)"><path d="M-15 25 h30 v5 h-30 z" class="light-bulb-base" /><path class="light-bulb-glass" id="light-bulb" d="M-20 0 a20,20 0 1,1 40,0" /><path d="M-10 25 v-10 h20 v10" class="light-bulb-base" /></g></svg>`,
            gate_identification: `<svg viewBox="0 0 800 300" class="w-full">
                <g id="circuit-and">
                    <text x="50" y="30" class="circuit-text" text-anchor="middle">A</text>
                    <text x="100" y="30" class="circuit-text" text-anchor="middle">B</text>
                    <text id="gid-in-and-a" x="50" y="60" class="gate-id-bit off" text-anchor="middle">0</text>
                    <text id="gid-in-and-b" x="100" y="60" class="gate-id-bit off" text-anchor="middle">0</text>
                    <path d="M50 70 V 100 H 75" class="circuit-line" /><path d="M100 70 V 100 H 75" class="circuit-line" />
                    <g transform="translate(75, 100)">
                        <rect class="drop-zone" id="drop-zone-and" data-type="and" width="100" height="60" rx="5"></rect>
                        <g id="placed-gate-and" style="visibility:hidden"><rect class="placed-gate-bg" width="100" height="60" rx="5" /><path class="gate-symbol" d="M15 10 H 50 C 85 10, 85 50, 50 50 H 15 Z" /></g>
                    </g>
                    <path d="M125 160 V 200" class="circuit-line" />
                    <text x="125" y="230" class="circuit-text" text-anchor="middle">Out</text>
                    <text id="gid-out-and" x="125" y="260" class="gate-id-bit off" text-anchor="middle">0</text>
                </g>
                <g id="circuit-or" transform="translate(275, 0)">
                    <text x="50" y="30" class="circuit-text" text-anchor="middle">A</text>
                    <text x="100" y="30" class="circuit-text" text-anchor="middle">B</text>
                    <text id="gid-in-or-a" x="50" y="60" class="gate-id-bit off" text-anchor="middle">0</text>
                    <text id="gid-in-or-b" x="100" y="60" class="gate-id-bit off" text-anchor="middle">0</text>
                    <path d="M50 70 V 100 H 75" class="circuit-line" /><path d="M100 70 V 100 H 75" class="circuit-line" />
                    <g transform="translate(75, 100)">
                         <rect class="drop-zone" id="drop-zone-or" data-type="or" width="100" height="60" rx="5"></rect>
                         <g id="placed-gate-or" style="visibility:hidden"><rect class="placed-gate-bg" width="100" height="60" rx="5" /><path class="gate-symbol" d="M15 10 Q 35 30, 15 50 C 35 50, 85 40, 85 30 C 85 20, 35 10, 15 10 Z" /></g>
                    </g>
                    <path d="M125 160 V 200" class="circuit-line" />
                    <text x="125" y="230" class="circuit-text" text-anchor="middle">Out</text>
                    <text id="gid-out-or" x="125" y="260" class="gate-id-bit off" text-anchor="middle">0</text>
                </g>
                <g id="circuit-not" transform="translate(550, 0)">
                    <text x="75" y="30" class="circuit-text" text-anchor="middle">A</text>
                    <text id="gid-in-not-a" x="75" y="60" class="gate-id-bit off" text-anchor="middle">0</text>
                    <path d="M75 70 V 100" class="circuit-line" />
                    <g transform="translate(50, 100)">
                        <rect class="drop-zone" id="drop-zone-not" data-type="not" width="100" height="60" rx="5"></rect>
                        <g id="placed-gate-not" style="visibility:hidden"><rect class="placed-gate-bg" width="100" height="60" rx="5" /><path class="gate-symbol" d="M20 10 L 70 30 L 20 50 Z" /><circle class="gate-symbol" cx="78" cy="30" r="8" /></g>
                    </g>
                    <path d="M100 160 V 200" class="circuit-line" />
                    <text x="100" y="230" class="circuit-text" text-anchor="middle">Out</text>
                    <text id="gid-out-not" x="100" y="260" class="gate-id-bit on" text-anchor="middle">1</text>
                </g>
            </svg>`
        };
        const transistorPartSvg = `<div class="draggable-part" data-type="transistor"><svg width="80" height="80" viewBox="0 0 100 100"><rect class="transistor-box" width="100" height="100" rx="5" /><text class="transistor-text" x="50" y="65" text-anchor="middle">T</text></svg></div>`;
        const gatePartsSvg = {
            not: `<div class="draggable-part" data-type="not"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 L 60 25 L 10 45 Z" /><circle class="gate-symbol" cx="68" cy="25" r="7" /><text x="35" y="30" class="gate-label">NOT</text></g></svg></div>`,
            and: `<div class="draggable-part" data-type="and"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 H 40 C 70 5, 70 45, 40 45 H 10 Z" /><text x="35" y="30" class="gate-label">AND</text></g></svg></div>`,
            or: `<div class="draggable-part" data-type="or"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 Q 30 25, 10 45 C 30 45, 70 35, 70 25 C 70 15, 30 5, 10 5 Z" /><text x="35" y="30" class="gate-label">OR</text></g></svg></div>`,
        };
        
        // --- Puzzle Launcher ---
        function launchPuzzle(stationId) {
            const pz = puzzleState[stationId];
            const isBuildPuzzle = pz.buildText || stationId === 'gate_identification';
            
            let partsBinHtml = '';
            if (isBuildPuzzle) {
                if (stationId === 'gate_identification') {
                    partsBinHtml = `<div id="parts-bin" class="flex flex-col gap-4">${gatePartsSvg.and} ${gatePartsSvg.or} ${gatePartsSvg.not}</div>`;
                } else if (stationId !== 'transistor_basics') {
                    const numTransistors = (stationId === 'and_gate' || stationId === 'or_gate') ? 2 : 1;
                    partsBinHtml = `<div id="parts-bin">${transistorPartSvg.repeat(numTransistors)}</div>`;
                }
            }

            const modalHtml = `
                <div id="instruction-text" class="text-center mb-6">
                    <h1 class="text-3xl font-bold text-white">${pz.title}</h1>
                    <p class="text-slate-400 max-w-2xl mx-auto">${isBuildPuzzle && pz.buildText ? pz.buildText : pz.text}</p>
                </div>
                <div class="circuit-bg p-8 rounded-lg shadow-2xl">
                    <div class="flex items-center justify-around gap-8">
                        <div id="controls-area" class="flex flex-col items-center gap-4">
                            ${partsBinHtml}
                            <div id="control-switch-container" class="hidden"></div>
                        </div>
                        <div id="schematic-area" class="w-full">${schematics[stationId]}</div>
                        <div id="output-bit-container" class="hidden flex-col items-center gap-2">
                            <div id="output-bit" class="bit-display output">0</div>
                            <p class="text-slate-400 font-mono">Output</p>
                        </div>
                    </div>
                    <div id="truth-table-container" class="hidden mt-8 text-center"></div>
                    <div class="mt-6 flex justify-end gap-4">
                        <button id="puzzle-close-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Exit</button>
                        <button id="puzzle-complete-btn" class="hidden bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded">Complete Station</button>
                    </div>
                </div>`;
            showModal(modalHtml);
            document.getElementById('puzzle-close-btn').addEventListener('click', closeModal);

            if (stationId === 'gate_identification') {
                setupGateIdPuzzle();
            } else if (isBuildPuzzle) {
                setupBuildMode(stationId);
            } else {
                setupTestMode(stationId);
            }
        }

        function setupBuildMode(stationId) {
            const parts = modalContentArea.querySelectorAll('.draggable-part');
            let placedCount = 0;
            const dropZones = modalContentArea.querySelectorAll('.drop-zone');

            parts.forEach((part) => {
                part.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (part.classList.contains('placed')) return;
                    const clone = part.cloneNode(true);
                    clone.classList.add('dragging');
                    document.body.appendChild(clone);
                    const moveClone = (moveEvent) => {
                        clone.style.left = `${moveEvent.clientX - 45}px`;
                        clone.style.top = `${moveEvent.clientY - 25}px`;
                    };
                    moveClone(e);
                    const drop = (upEvent) => {
                        clone.remove();
                        const dropTarget = document.elementFromPoint(upEvent.clientX, upEvent.clientY);
                        if (dropTarget && dropTarget.classList.contains('drop-zone') && !dropTarget.id.includes('filled') && dropTarget.dataset.type === part.dataset.type) {
                            part.style.display = 'none';
                            part.classList.add('placed');
                            if (dropTarget.nextElementSibling) {
                                dropTarget.nextElementSibling.style.visibility = 'visible';
                            }
                            dropTarget.id += '-filled';
                            placedCount++;
                            if (placedCount === dropZones.length) {
                                if(stationId === 'gate_identification') {
                                    const completeButton = document.getElementById('puzzle-complete-btn');
                                    completeButton.classList.remove('hidden');
                                    completeButton.onclick = () => { completePuzzle(stationId); closeModal(); };
                                } else {
                                    setupTestMode(stationId);
                                }
                            }
                        }
                        document.removeEventListener('mousemove', moveClone);
                        document.removeEventListener('mouseup', drop, { once: true });
                    };
                    document.addEventListener('mousemove', moveClone);
                    document.addEventListener('mouseup', drop, { once: true });
                });
            });
        }

        function setupGateIdPuzzle() {
            setupBuildMode('gate_identification'); 
            let counter = 0;
            const combinations = [[0,0], [0,1], [1,0], [1,1]];
            const updateBit = (element, value) => {
                if(!element) return;
                element.textContent = value;
                element.classList.toggle('on', value === 1);
                element.classList.toggle('off', value === 0);
            };
            puzzleInterval = setInterval(() => {
                const [a, b] = combinations[counter];
                updateBit(document.getElementById('gid-in-and-a'), a);
                updateBit(document.getElementById('gid-in-and-b'), b);
                updateBit(document.getElementById('gid-out-and'), a & b);
                updateBit(document.getElementById('gid-in-or-a'), a);
                updateBit(document.getElementById('gid-in-or-b'), b);
                updateBit(document.getElementById('gid-out-or'), a | b);
                updateBit(document.getElementById('gid-in-not-a'), a);
                updateBit(document.getElementById('gid-out-not'), a ? 0 : 1);
                counter = (counter + 1) % combinations.length;
            }, 1500);
        }

        function setupTestMode(stationId) {
            const pz = puzzleState[stationId];
            if (pz.buildText) {
                document.querySelector('#instruction-text p').innerHTML = pz.testText;
                const bin = document.getElementById('parts-bin');
                if(bin) bin.style.display = 'none';
            }
            
            const controlsContainer = document.getElementById('control-switch-container');
            const outputContainer = document.getElementById('output-bit-container');
            const truthTableContainer = document.getElementById('truth-table-container');
            
            controlsContainer.classList.remove('hidden');
            if (stationId !== 'transistor_basics') {
                outputContainer.classList.remove('hidden');
                truthTableContainer.classList.remove('hidden');
            }

            let inputs = [];
            let controlsHtml = '';
            if (stationId === 'transistor_basics' || stationId === 'not_gate') {
                inputs = [0];
                controlsHtml = `<div class="flex flex-col items-center gap-2"><div id="control-A" class="bit-display input off">0</div><p class="text-slate-400 font-mono">${stationId === 'not_gate' ? 'Input' : 'Control'}</p></div>`;
            } else {
                inputs = [0, 0];
                controlsHtml = `<div class="flex flex-col items-center gap-2"><div id="control-A" class="bit-display input off">0</div><p class="text-slate-400 font-mono">Input A</p></div><div class="flex flex-col items-center gap-2 mt-4"><div id="control-B" class="bit-display input off">0</div><p class="text-slate-400 font-mono">Input B</p></div>`;
            }
            controlsContainer.innerHTML = controlsHtml;

            const truthTable = {};
            const updateCircuit = () => {
                const lightBulb = document.getElementById('light-bulb');
                const outputBit = document.getElementById('output-bit');
                let isBulbOn = false;

                switch (stationId) {
                    case 'transistor_basics':
                        isBulbOn = inputs[0] === 1;
                        document.getElementById('control-line').classList.toggle('control-powered', isBulbOn);
                        document.getElementById('control-pin').classList.toggle('control-powered', isBulbOn);
                        document.getElementById('transistor-box').classList.toggle('active', isBulbOn);
                        document.getElementById('output-pin').classList.toggle('main-powered', isBulbOn);
                        document.getElementById('power-out').classList.toggle('main-powered', isBulbOn);
                        if (isBulbOn) {
                            const completeButton = document.getElementById('puzzle-complete-btn');
                            if (completeButton) {
                                completeButton.classList.remove('hidden');
                                completeButton.onclick = () => { completePuzzle(stationId); closeModal(); };
                            }
                        }
                        break;
                    case 'not_gate':
                        isBulbOn = inputs[0] === 0;
                        document.getElementById('control-line').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('control-pin-0').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('transistor-box-0').classList.toggle('active', inputs[0] === 1);
                        document.getElementById('diverter-pin-0').classList.toggle('main-powered', inputs[0] === 1);
                        document.getElementById('power-to-bulb').classList.toggle('main-powered', isBulbOn);
                        break;
                    case 'and_gate':
                        isBulbOn = inputs[0] === 1 && inputs[1] === 1;
                        document.getElementById('control-line-A').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('control-pin-0').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('transistor-box-0').classList.toggle('active', inputs[0] === 1);
                        document.getElementById('power-mid').classList.toggle('main-powered', inputs[0] === 1);
                        document.getElementById('control-line-B').classList.toggle('control-powered', inputs[1] === 1);
                        document.getElementById('control-pin-1').classList.toggle('control-powered', inputs[1] === 1);
                        document.getElementById('transistor-box-1').classList.toggle('active', inputs[1] === 1);
                        document.getElementById('power-out').classList.toggle('main-powered', isBulbOn);
                        break;
                    case 'or_gate':
                        isBulbOn = inputs[0] === 1 || inputs[1] === 1;
                        document.getElementById('control-line-A').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('control-pin-0').classList.toggle('control-powered', inputs[0] === 1);
                        document.getElementById('transistor-box-0').classList.toggle('active', inputs[0] === 1);
                        document.getElementById('power-top-out').classList.toggle('main-powered', inputs[0] === 1);
                        document.getElementById('control-line-B').classList.toggle('control-powered', inputs[1] === 1);
                        document.getElementById('control-pin-1').classList.toggle('control-powered', inputs[1] === 1);
                        document.getElementById('transistor-box-1').classList.toggle('active', inputs[1] === 1);
                        document.getElementById('power-bottom-out').classList.toggle('main-powered', inputs[1] === 1);
                        document.getElementById('power-final').classList.toggle('main-powered', isBulbOn);
                        break;
                }

                if (lightBulb) lightBulb.classList.toggle('on', isBulbOn);
                if (outputBit) {
                    outputBit.textContent = isBulbOn ? '1' : '0';
                    outputBit.classList.toggle('on', isBulbOn);
                    outputBit.classList.toggle('off', !isBulbOn);
                }
                
                truthTable[inputs.join('')] = isBulbOn ? 1 : 0;
                updateTruthTable(stationId, truthTable);
            };

            ['A', 'B'].forEach((char, index) => {
                const control = document.getElementById(`control-${char}`);
                if (control) {
                    control.addEventListener('click', () => {
                        inputs[index] = inputs[index] === 0 ? 1 : 0;
                        control.textContent = inputs[index];
                        control.classList.toggle('on');
                        control.classList.toggle('off');
                        updateCircuit();
                    });
                }
            });
            
            updateCircuit();
        }

        function updateTruthTable(stationId, truthTable) {
            if (stationId === 'transistor_basics' || stationId === 'gate_identification') return;
            const container = document.getElementById('truth-table-container');
            const symbols = {
                not_gate: `<svg width="60" height="40" viewBox="0 0 100 60"><path d="M20 10 L 80 30 L 20 50 Z" stroke="#cbd5e1" stroke-width="6" fill="none"/><circle cx="88" cy="30" r="8" stroke="#cbd5e1" stroke-width="6" fill="none"/></svg>`,
                and_gate: `<svg width="80" height="40" viewBox="0 0 100 60"><path d="M20 10 H 50 C 80 10, 80 50, 50 50 H 20 Z" stroke="#cbd5e1" stroke-width="6" fill="none"/></svg>`,
                or_gate: `<svg width="80" height="50" viewBox="0 0 100 60"><path d="M20 10 Q 40 30, 20 50 C 40 50, 80 40, 80 30 C 80 20, 40 10, 20 10 Z" stroke="#cbd5e1" stroke-width="6" fill="none"/></svg>`,
            };
            const headers = stationId === 'not_gate' ? `<th>In (A)</th><th>Out</th>` : `<th>In (A)</th><th>In (B)</th><th>Out</th>`;
            const combinations = stationId === 'not_gate' ? ['0', '1'] : ['00', '01', '10', '11'];
            
            let rows = '';
            for (const combo of combinations) {
                const discovered = truthTable[combo] !== undefined;
                const output = discovered ? truthTable[combo] : '?';
                const inputs = combo.split('');
                rows += `<tr class="${discovered ? 'discovered' : ''}">${inputs.map(i => `<td>${i}</td>`).join('')}<td>${output}</td></tr>`;
            }
            
            container.innerHTML = `<div class="flex justify-center items-center gap-4"><h2 class="text-xl font-bold text-white">Truth Table</h2>${symbols[stationId] || ''}</div><table class="truth-table mx-auto mt-2"><thead><tr>${headers}</tr></thead><tbody>${rows}</tbody></table>`;

            if (Object.keys(truthTable).length === combinations.length) {
                const completeButton = document.getElementById('puzzle-complete-btn');
                if (completeButton) {
                    completeButton.classList.remove('hidden');
                    completeButton.onclick = () => { completePuzzle(stationId); closeModal(); };
                }
            }
        }

        // --- Drawing & Game Loop ---
        function checkCollision(r1, r2) { return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y; }
        function drawSprite(sprite, x, y, scale, baseColor) {
            const colors = [...sprite.colors];
            if (baseColor) colors[1] = baseColor;
            for (let r = 0; r < sprite.height; r++) for (let col = 0; col < sprite.width; col++) {
                const index = parseInt(sprite.data[r][col]);
                if (index !== 0 && colors[index]) {
                    ctx.fillStyle = colors[index];
                    ctx.fillRect(x + col * scale, y + r * scale, scale, scale);
                }
            }
        }

        function drawGateSymbolOnCanvas(ctx, symbol, x, y, size) {
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.fillStyle = 'none';

            ctx.beginPath();
            switch (symbol) {
                case 'and':
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y);
                    ctx.arc(x + size / 2, y + size / 2, size / 2, -Math.PI / 2, Math.PI / 2);
                    ctx.lineTo(x, y + size);
                    ctx.closePath();
                    break;
                case 'or':
                    ctx.moveTo(x, y);
                    ctx.quadraticCurveTo(x + size * 0.4, y + size / 2, x, y + size);
                    ctx.quadraticCurveTo(x + size * 0.6, y + size, x + size, y + size / 2);
                    ctx.quadraticCurveTo(x + size * 0.6, y, x, y);
                    break;
                case 'not':
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size * 0.8, y + size / 2);
                    ctx.lineTo(x, y + size);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(x + size * 0.9, y + size / 2, size * 0.1, 0, 2 * Math.PI);
                    break;
            }
            ctx.stroke();
        }

        function drawWorld() {
            for (let y = 0; y < canvas.height; y += TILE_SIZE) for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                ctx.fillStyle = ((x / TILE_SIZE) % 2 === (y / TILE_SIZE) % 2) ? palette.floor_dark : palette.floor_light;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
            ctx.fillStyle = palette.platform;
            ctx.fillRect(centralPlatform.x, centralPlatform.y, centralPlatform.width, centralPlatform.height);
            ctx.strokeStyle = palette.platform_trim;
            ctx.lineWidth = 4;
            ctx.strokeRect(centralPlatform.x, centralPlatform.y, centralPlatform.width, centralPlatform.height);
            
            const symbolOrder = ['not', 'and', 'or'];
            const collected = symbolOrder.filter(s => centralPlatform.collectedSymbols.includes(s));
            const symbolSize = 50;
            const totalSymbolWidth = collected.length * symbolSize;
            const totalPadding = centralPlatform.width - totalSymbolWidth;
            const padding = totalPadding / (collected.length + 1);

            collected.forEach((symbol, index) => {
                const symbolX = centralPlatform.x + (padding * (index + 1)) + (symbolSize * index);
                const symbolY = centralPlatform.y + (centralPlatform.height - symbolSize) / 2;
                drawGateSymbolOnCanvas(ctx, symbol, symbolX, symbolY, symbolSize);
            });

            if (!floorIsComplete) {
                const activeStationId = puzzleSequence[currentPuzzleIndex];
                const activeStation = worldObjects.find(obj => obj.id === activeStationId);
                if (activeStation) {
                    ctx.fillStyle = 'rgba(253, 224, 71, 0.3)';
                    ctx.beginPath();
                    ctx.arc(activeStation.x + activeStation.width / 2, activeStation.y + activeStation.height / 2, 60, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            worldObjects.forEach(obj => {
                if (obj.type === 'station') {
                    const isCompleted = puzzleState[obj.id].completed;
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE, isCompleted ? obj.onColor : obj.color);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                } else if (obj.type === 'stairs') {
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE);
                    ctx.fillStyle = (obj.direction === 'up' && floorIsComplete) || obj.direction === 'down' ? '#a3e635' : '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                }
            });
        }
        function update() {
            let nextX = player.x, nextY = player.y;
            if (keys.ArrowUp) nextY -= player.speed;
            if (keys.ArrowDown) nextY += player.speed;
            if (keys.ArrowLeft) nextX -= player.speed;
            if (keys.ArrowRight) nextX += player.speed;
            if (nextX < 0) nextX = 0;
            if (nextX + player.width > canvas.width) nextX = canvas.width - player.width;
            if (nextY < 0) nextY = 0;
            if (nextY + player.height > canvas.height) nextY = canvas.height - player.height;
            
            const tempPlayer = { ...player, x: nextX, y: nextY };
            let collision = checkCollision(tempPlayer, centralPlatform);

            if (!collision) {
                player.x = nextX;
                player.y = nextY;
            }
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            drawSprite(playerSprite, player.x, player.y, PIXEL_SCALE);
            let interactionTarget = worldObjects.find(obj => {
                if (obj.type === 'platform') return false;
                return checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 });
            });

            if (interactionTarget) {
                ctx.fillStyle = 'white';
                ctx.font = '16px "Inter"';
                ctx.textAlign = 'center';
                ctx.fillText(`Press 'E' to interact with ${interactionTarget.name}`, canvas.width / 2, canvas.height - 30);
            }
        }
        function gameLoop() {
            if (modal.classList.contains('hidden')) update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        function handleInteraction(obj) {
            if (obj.type === 'stairs') {
                launchStairsModal(obj);
                return;
            }

            if (obj.type === 'station') {
                const targetStationIndex = puzzleSequence.indexOf(obj.id);
                if (targetStationIndex > currentPuzzleIndex) {
                    showMessage('Out of Sequence', 'This station is not active yet. Please find the highlighted station to proceed.');
                } else {
                    launchPuzzle(obj.id);
                }
            }
        }
        window.addEventListener('keydown', (e) => {
            if (modal.classList.contains('hidden')) {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'e') {
                    const interactionTarget = worldObjects.find(obj => {
                        if (obj.type === 'platform') return false;
                        return checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 });
                    });
                    if(interactionTarget) handleInteraction(interactionTarget);
                }
            }
        });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        window.addEventListener('resize', initializeWorld);

        // --- Start the game! ---
        function startGame() {
            initializeWorld();
            const introText = "Now that you understand bits, let's see how they're used. Everything starts with the Transistor, a tiny switch. Follow the spotlight to learn the basics.";
            showMessage("Welcome to Floor 2!", introText, gameLoop);
        }
        startGame();
    </script>
</body>
</html>


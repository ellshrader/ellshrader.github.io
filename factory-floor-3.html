<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Floor 3 - Repair Bay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
            overflow: hidden;
            image-rendering: pixelated;
        }
        .game-container-wrapper {
            width: 100%; height: 100vh; display: flex; flex-direction: column;
            align-items: center; justify-content: center; padding: 1rem;
        }
        .game-container {
            width: 100%; max-width: 1000px; text-align: center; margin-bottom: 1rem;
        }
        canvas {
            border: 2px solid #f97316; /* Orange theme for repair floor */
            border-radius: 0.5rem; background-color: #1f2937;
            width: 100%; height: auto; max-height: 80vh;
        }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background-color: #1f2937; padding: 1.5rem; border-radius: 0.5rem;
            border: 1px solid #f97316; color: #d1d5db; max-width: 95%;
            width: 900px; text-align: center;
        }
        .circuit-bg { background-color: #1e293b; }
        .bit-display {
            width: 60px; height: 60px; border-radius: 0.5rem; border: 4px solid #475569;
            font-family: 'Roboto Mono', monospace; font-size: 2rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .bit-display.input.off { background-color: #475569; color: #f43f5e; }
        .bit-display.input.on { background-color: #1e293b; color: #4ade80; border-color: #4ade80; }
        .output-indicator {
            padding: 0.5rem 1rem; border-radius: 0.5rem; font-family: 'Roboto Mono', monospace;
            font-weight: bold; transition: all 0.3s;
        }
        .output-indicator.off { background-color: #b91c1c; color: #fecaca; }
        .output-indicator.on { background-color: #166534; color: #dcfce7; }
        .circuit-line { stroke: #475569; stroke-width: 8; stroke-linecap: round; transition: stroke 0.3s; }
        .circuit-line.powered { stroke: #4ade80; }
        .circuit-text { font-family: 'Roboto Mono', monospace; fill: #94a3b8; font-size: 14px; }
        .draggable-part { cursor: grab; }
        .draggable-part.dragging { cursor: grabbing; transform: scale(1.1); opacity: 0.7; position: absolute; z-index: 1000; }
        .drop-zone { fill: rgba(249, 115, 22, 0.3); stroke: #f97316; stroke-width: 2; stroke-dasharray: 4; transition: fill 0.2s; }
        .placed-gate-bg { fill: #1e293b; }
        .gate-symbol { stroke: #cbd5e1; stroke-width: 6; fill: none; }
        .gate-label {
            font-family: 'Roboto Mono', monospace;
            fill: #e5e7eb;
            font-size: 18px;
            font-weight: bold;
            text-anchor: middle;
            user-select: none;
        }
        .problem-text {
            border-left: 4px solid #f97316;
            padding-left: 1rem;
            background-color: rgba(249, 115, 22, 0.1);
        }
        .discovery-text {
            border-left: 4px solid #a855f7;
            padding-left: 1rem;
            background-color: rgba(168, 85, 247, 0.1);
        }
        .stairs-button {
            background-color: #f97316;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            border: none;
            font-weight: bold;
        }
        .stairs-button:hover { background-color: #fb923c; }
        .stairs-button.cancel { background-color: #6b7280; }
        .stairs-button.cancel:hover { background-color: #7f8794; }
    </style>
</head>
<body class="bg-slate-900">

    <div class="game-container-wrapper">
        <div class="game-container">
            <h1 class="text-3xl font-bold text-orange-500">Diagnostics & Repair</h1>
            <p class="text-gray-400">Use Arrow Keys to move. Press 'E' to interact.</p>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="modal" class="modal-backdrop hidden">
            <div id="modal-content-area" class="modal-content"></div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Asset Definitions ---
        const TILE_SIZE = 40;
        const PIXEL_SCALE = 4;
        const palette = {
            skin: '#fde68a', hair: '#4a2c2a', shirt: '#ef4444', pants: '#3b82f6',
            floor_dark: '#4a2c2a', floor_light: '#78350f', platform: '#374151', platform_trim: '#f97316',
            station_base: '#7c2d12', station_base_on: '#9a3412',
            station_accent: '#fed7aa',
            foreman_hat: '#f97316', foreman_shirt: '#15803d',
        };
        const playerSprite = { width: 8, height: 10, data: ["00111100","01111110","00222200","00333300","03333330","00333300","00400400","00400400","04400440","04400440"], colors: [null, palette.hair, palette.skin, palette.shirt, palette.pants] };
        const foremanSvg = `<svg class="foreman-sprite" viewBox="0 0 16 16" style="width:64px; height:64px; margin-right: 1rem; flex-shrink:0;"><path fill="${palette.skin}" d="M5,6h6v5H5V6z"/><path fill="${palette.foreman_hat}" d="M4,4h8v2H4V4z"/><path fill="${palette.foreman_shirt}" d="M4,11h8v3H4V11z"/><path fill="#000" d="M6,7h1v1H6V7zm3,0h1v1H9V7z"/></svg>`;
        const stationSprite = { width: 12, height: 10, data: ["001111111100","012222222210","122222222221","122111111221","122103300121","122103030121","122111111221","122222222221","012222222210","001111111100"], colors: [null, palette.station_base, palette.station_base_on, palette.station_accent] };

        // --- Game State ---
        const player = { x: 120, y: 50, width: playerSprite.width * PIXEL_SCALE, height: playerSprite.height * PIXEL_SCALE, speed: 4 };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let worldObjects = [];
        const puzzleSequence = ['safety_door', 'conveyor_belt', 'alarm_system', 'sorting_machine'];
        let currentPuzzleIndex = 0;
        let floorIsComplete = false;
        const puzzleState = {
            'safety_door': { name: 'Safety Door', completed: false, title: 'Repair: Safety Door', problem: "This safety door should only open if <strong>both</strong> the 'Key Turned' AND 'Pressure Safe' lights are on. It's not working right!", correctGate: 'and', outputText: ['DOOR CLOSED', 'DOOR OPEN'] },
            'conveyor_belt': { name: 'Conveyor Belt', completed: false, title: 'Repair: Conveyor Belt', problem: "This conveyor belt needs to run if <strong>either</strong> 'Manual Switch A' OR 'Manual Switch B' is activated. It's stuck!", correctGate: 'or', outputText: ['BELT STOPPED', 'BELT RUNNING'] },
            'alarm_system': { name: 'Alarm System', completed: false, title: 'Repair: Alarm System', problem: "This alarm should be OFF when the 'System OK' light is ON. It's wired backwards!", correctGate: 'not', outputText: ['ALARM ON', 'ALARM OFF'] },
            'sorting_machine': { name: 'Sorter', completed: false, title: 'Repair: Sorting Machine', problem: "This sorter should activate for every item <strong>except</strong> when it detects 'Metal' AND 'Heavy' at the same time. It needs a special part you have to build.", correctGate: 'nand', outputText: ['SORTER ACTIVE', 'SORTER IDLE'], discovery: "You've just created a <strong>NAND gate</strong> (short for NOT-AND). By combining simple gates, you can build more powerful and complex ones! Notice how it's the exact opposite of a regular AND gate." },
        };

        // --- SCRIPT FOR LEVEL TRANSITION ---
        const stairsSprite = {
            width: 12, height: 10, data: [
                "000000000011", "000000000111", "000000001110", "000000011100",
                "000000111000", "000001110000", "000011100000", "000111000000",
                "001110000000", "011100000000"
            ],
            colors: [null, '#a16207']
        };
        // --- END SCRIPT FOR LEVEL TRANSITION ---

        // --- World Initialization ---
        function initializeWorld() {
            const gameContainer = document.querySelector('.game-container');
            canvas.width = gameContainer.offsetWidth;
            canvas.height = window.innerHeight * 0.75;
            ctx.imageSmoothingEnabled = false;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            player.x = centerX - player.width / 2;
            player.y = canvas.height - player.height - 40;

            const stationSpacing = (canvas.width - 200) / puzzleSequence.length;

            worldObjects = puzzleSequence.map((id, index) => {
                const stationX = 100 + (stationSpacing * index) + (stationSpacing/2);
                const stationY = centerY;
                return {
                    type: 'station', id, name: puzzleState[id].name,
                    x: stationX - (stationSprite.width * PIXEL_SCALE / 2), y: stationY - (stationSprite.height * PIXEL_SCALE / 2),
                    width: stationSprite.width * PIXEL_SCALE, height: stationSprite.height * PIXEL_SCALE,
                    sprite: stationSprite, onColor: stationSprite.colors[2], color: stationSprite.colors[1]
                };
            });
            
            // Add stairs objects
            worldObjects.push({
                type: 'stairs', id: 'stairs_up', direction: 'up',
                name: 'Stairs Up', nextFloor: 'factory-floor-4.html',
                x: canvas.width - (stairsSprite.width * PIXEL_SCALE) - 20,
                y: canvas.height - (stairsSprite.height * PIXEL_SCALE) - 20,
                width: stairsSprite.width * PIXEL_SCALE, height: stairsSprite.height * PIXEL_SCALE,
                sprite: stairsSprite
            });
            worldObjects.push({
                type: 'stairs', id: 'stairs_down', direction: 'down',
                name: 'Stairs Down', nextFloor: 'factory-floor-2.html',
                x: 20,
                y: canvas.height - (stairsSprite.height * PIXEL_SCALE) - 20,
                width: stairsSprite.width * PIXEL_SCALE, height: stairsSprite.height * PIXEL_SCALE,
                sprite: stairsSprite
            });
        }

        // --- Modal & Puzzle Logic ---
        const modal = document.getElementById('modal');
        const modalContentArea = document.getElementById('modal-content-area');
        function showModal(content) { modalContentArea.innerHTML = content; modal.classList.remove('hidden'); }
        function closeModal() { modal.classList.add('hidden'); modalContentArea.innerHTML = ''; }
        function showMessage(title, text, onCloseCallback) {
            showModal(`<div class="p-4"><div class="flex items-center mb-4">${foremanSvg}<div><h2 class="text-2xl font-bold text-left">${title}</h2><p class="text-left">${text}</p></div></div><button id="puzzle-close" class="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">OK</button></div>`);
            document.getElementById('puzzle-close').addEventListener('click', () => { closeModal(); if (onCloseCallback) onCloseCallback(); });
        }
        
        function launchStairsModal(stair) {
            if (stair.direction === 'up' && !floorIsComplete) {
                showMessage("Wait!", "Hey, not yet. We're not done in here. Finish repairing these machines first!");
                return;
            }

            let buttonsHtml = '';
            if (stair.direction === 'up') {
                buttonsHtml += `<button class="stairs-button" onclick="window.location.href='${stair.nextFloor}'">Go Up to Floor 4</button>`;
            }
            if (stair.direction === 'down') {
                buttonsHtml += `<button class="stairs-button" onclick="window.location.href='${stair.nextFloor}'">Go Down to Floor 2</button>`;
            }
            buttonsHtml += `<button class="stairs-button cancel" onclick="closeModal()">Stay Here</button>`;

            showModal(`<div class="puzzle-container">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Stairs</h2>
                <div>${buttonsHtml}</div>
            </div>`);
        }

        function completePuzzle(stationId) {
            const pz = puzzleState[stationId];
            if (pz && !pz.completed) {
                pz.completed = true;
                if (puzzleSequence[currentPuzzleIndex] === stationId) {
                    currentPuzzleIndex++;
                }
            }
            if (currentPuzzleIndex >= puzzleSequence.length && !floorIsComplete) {
                floorIsComplete = true;
                setTimeout(() => {
                    showMessage("Floor Complete!", "Great work, technician! You've got these machines running perfectly. The stairs to the final assembly floor are now open.");
                }, 500);
            }
        }

        // --- Puzzle Templates ---
        const schematics = {
            two_input: `<svg viewBox="0 0 400 150" class="w-full">
                <path id="line-in-a" d="M25 45 H 150" class="circuit-line" />
                <path id="line-in-b" d="M25 105 H 150" class="circuit-line" />
                <g transform="translate(150, 40)">
                    <rect id="drop-zone-0" class="drop-zone" data-type="gate" width="100" height="70" rx="5" />
                    <g id="placed-gate-0" style="visibility: hidden;"></g>
                </g>
                <path id="line-out" d="M250 75 H 375" class="circuit-line" />
            </svg>`,
            one_input: `<svg viewBox="0 0 400 150" class="w-full">
                <path id="line-in-a" d="M25 75 H 150" class="circuit-line" />
                <g transform="translate(150, 40)">
                    <rect id="drop-zone-0" class="drop-zone" data-type="gate" width="100" height="70" rx="5" />
                    <g id="placed-gate-0" style="visibility: hidden;"></g>
                </g>
                <path id="line-out" d="M250 75 H 375" class="circuit-line" />
            </svg>`,
            nand_build: `<svg viewBox="0 0 500 150" class="w-full">
                 <text x="10" y="45" class="circuit-text">A</text><path id="line-in-a" d="M25 45 H 100" class="circuit-line" />
                 <text x="10" y="105" class="circuit-text">B</text><path id="line-in-b" d="M25 105 H 100" class="circuit-line" />
                 <!-- Build Area -->
                 <rect x="100" y="20" width="275" height="110" rx="5" fill="none" stroke="#475569" stroke-dasharray="4"/>
                 <text x="237.5" y="15" class="circuit-text" text-anchor="middle">Build Area</text>
                 <g transform="translate(120, 40)"><rect id="build-zone-0" class="drop-zone" data-type="and" width="100" height="70" rx="5" /><g id="placed-gate-build-0" style="visibility: hidden;"><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 10 H 50 C 85 10, 85 60, 50 60 H 15 Z" /></g></g>
                 <path id="line-mid" d="M220 75 H 255" class="circuit-line" />
                 <g transform="translate(255, 40)"><rect id="build-zone-1" class="drop-zone" data-type="not" width="100" height="70" rx="5" /><g id="placed-gate-build-1" style="visibility: hidden;"><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 5 L 75 35 L 15 65 Z" /><circle class="gate-symbol" cx="85" cy="35" r="8" /></g></g>
                <path id="line-out" d="M375 75 H 475" class="circuit-line" />
            </svg>`
        };
        const gatePartsSvg = {
            not: `<div class="draggable-part" data-type="not"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 L 60 25 L 10 45 Z" /><circle class="gate-symbol" cx="68" cy="25" r="7" /><text x="35" y="30" class="gate-label">NOT</text></g></svg></div>`,
            and: `<div class="draggable-part" data-type="and"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 H 40 C 70 5, 70 45, 40 45 H 10 Z" /><text x="35" y="30" class="gate-label">AND</text></g></svg></div>`,
            or: `<div class="draggable-part" data-type="or"><svg width="90" height="50" viewBox="0 0 90 50"><g><path class="gate-symbol" d="M10 5 Q 30 25, 10 45 C 30 45, 70 35, 70 25 C 70 15, 30 5, 10 5 Z" /><text x="35" y="30" class="gate-label">OR</text></g></svg></div>`,
        };
        const gateSymbols = {
            not: `<g><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 5 L 75 35 L 15 65 Z" /><circle class="gate-symbol" cx="85" cy="35" r="8" /></g>`,
            and: `<g><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 10 H 50 C 85 10, 85 60, 50 60 H 15 Z" /></g>`,
            or: `<g><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 10 Q 35 35, 15 60 C 35 60, 85 50, 85 35 C 85 20, 35 10, 15 10 Z" /></g>`,
            nand: `<g><rect class="placed-gate-bg" width="100" height="70" rx="5" /><path class="gate-symbol" d="M15 10 H 50 C 85 10, 85 60, 50 60 H 15 Z" /><circle class="gate-symbol" cx="85" cy="35" r="8" /></g>`,
        }
        
        // --- Puzzle Launcher ---
        function launchPuzzle(stationId) {
            const pz = puzzleState[stationId];
            let partsBinHtml = '';
            let schematicHtml = '';
            let controlsHtml = '';
            let inputs = [0, 0];

            if (stationId === 'sorting_machine') {
                partsBinHtml = `<div id="parts-bin" class="flex flex-col gap-4">${gatePartsSvg.and} ${gatePartsSvg.not}</div>`;
                schematicHtml = schematics.nand_build;
                controlsHtml = `<div class="flex flex-col items-center gap-2"><div id="control-A" class="bit-display input off">0</div><p class="text-slate-400 font-mono">Metal</p></div><div class="flex flex-col items-center gap-2 mt-4"><div id="control-B" class="bit-display input off">0</div><p class="text-slate-400 font-mono">Heavy</p></div>`;
            } else {
                partsBinHtml = `<div id="parts-bin" class="flex flex-col gap-4">${gatePartsSvg.and} ${gatePartsSvg.or} ${gatePartsSvg.not}</div>`;
                if (stationId === 'alarm_system') {
                    schematicHtml = schematics.one_input;
                    controlsHtml = `<div class="flex flex-col items-center gap-2"><div id="control-A" class="bit-display input off">0</div><p class="text-slate-400 font-mono">System OK</p></div>`;
                    inputs = [0];
                } else {
                    schematicHtml = schematics.two_input;
                    const labels = stationId === 'safety_door' ? ['Key Turned', 'Pressure Safe'] : ['Switch A', 'Switch B'];
                    controlsHtml = `<div class="flex flex-col items-center gap-2"><div id="control-A" class="bit-display input off">0</div><p class="text-slate-400 font-mono">${labels[0]}</p></div><div class="flex flex-col items-center gap-2 mt-4"><div id="control-B" class="bit-display input off">0</div><p class="text-slate-400 font-mono">${labels[1]}</p></div>`;
                }
            }

            const modalHtml = `
                <div id="instruction-text" class="text-center mb-6">
                    <h1 class="text-3xl font-bold text-white">${pz.title}</h1>
                    <div class="problem-text text-slate-300 max-w-3xl mx-auto mt-4 p-3 rounded-md text-left">
                        <h2 class="font-bold text-orange-400">Foreman's Orders:</h2>
                        <p>${pz.problem}</p>
                    </div>
                    <div id="discovery-text" class="hidden discovery-text text-slate-300 max-w-3xl mx-auto mt-4 p-3 rounded-md text-left"></div>
                </div>
                <div class="circuit-bg p-8 rounded-lg shadow-2xl">
                    <div class="flex items-center justify-around gap-8">
                        <div id="controls-area" class="flex flex-col items-center gap-4">
                            ${partsBinHtml}
                        </div>
                        <div class="flex-grow flex flex-col items-center">
                            <div class="flex items-center gap-6">
                                <div id="control-switch-container">${controlsHtml}</div>
                                <div id="schematic-area" class="w-full">${schematicHtml}</div>
                                <div id="output-indicator-container" class="flex flex-col items-center gap-2">
                                    <div id="output-indicator" class="output-indicator off"></div>
                                    <p class="text-slate-400 font-mono">Status</p>
                                </div>
                            </div>
                            <div id="feedback-text" class="h-8 mt-4 text-xl font-bold"></div>
                        </div>
                    </div>
                    <div class="mt-6 flex justify-end gap-4">
                        <button id="puzzle-close-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Exit</button>
                        <button id="puzzle-complete-btn" class="hidden bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Complete Station</button>
                    </div>
                </div>`;
            showModal(modalHtml);
            
            const closeButton = document.getElementById('puzzle-close-btn');
            closeButton.addEventListener('click', closeModal);
            
            document.getElementById('puzzle-complete-btn').addEventListener('click', () => {
                closeModal();
            });

            let placedGateType = null;
            let nandBuilt = false;
            let puzzleSolved = false;

            const updateCircuit = () => {
                const [a, b] = inputs;
                let outputValue = 0;
                let isCorrect = false;

                const setPower = (id, condition) => document.getElementById(id)?.classList.toggle('powered', !!condition);
                
                let gateLogic = (inA, inB) => 0; 
                if (placedGateType) {
                    switch(placedGateType) {
                        case 'and': gateLogic = (inA, inB) => inA && inB; break;
                        case 'or':  gateLogic = (inA, inB) => inA || inB; break;
                        case 'not': gateLogic = (inA, inB) => !inA; break;
                        case 'nand':gateLogic = (inA, inB) => !(inA && inB); break;
                    }
                }

                if (stationId === 'sorting_machine') {
                    const andOut = a && b;
                    const notOut = !andOut;
                    if(nandBuilt) {
                        setPower('line-in-a', a);
                        setPower('line-in-b', b);
                        setPower('line-mid', andOut);
                        setPower('line-out', notOut);
                        outputValue = notOut;
                        isCorrect = true;
                    }
                } else {
                    outputValue = gateLogic(a, b);
                    setPower('line-in-a', a);
                    if (inputs.length > 1) setPower('line-in-b', b);
                    setPower('line-out', outputValue);
                    if (placedGateType === pz.correctGate) {
                        isCorrect = true;
                    }
                }

                const outputIndicator = document.getElementById('output-indicator');
                const [offText, onText] = pz.outputText;
                outputIndicator.textContent = outputValue ? onText : offText;
                outputIndicator.classList.toggle('on', !!outputValue);
                outputIndicator.classList.toggle('off', !outputValue);

                const feedback = document.getElementById('feedback-text');
                if (isCorrect && !puzzleSolved) {
                    puzzleSolved = true;
                    feedback.textContent = "SYSTEM FIXED!";
                    feedback.className = 'h-8 mt-4 text-xl font-bold text-green-400';
                    completePuzzle(stationId);
                    
                    document.getElementById('puzzle-complete-btn').classList.remove('hidden');
                    
                    const keepPlayingBtn = document.getElementById('puzzle-close-btn');
                    keepPlayingBtn.textContent = "Keep Playing";
                    keepPlayingBtn.removeEventListener('click', closeModal);
                    keepPlayingBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    keepPlayingBtn.classList.add('bg-gray-800', 'text-gray-400', 'cursor-default');

                } else if (placedGateType && !isCorrect) {
                    feedback.textContent = "INCORRECT PART!";
                    feedback.className = 'h-8 mt-4 text-xl font-bold text-red-400';
                }
            };

            const dropHandler = (part, dropTarget) => {
                const partType = part.dataset.type;
                part.style.display = 'none';
                part.classList.add('placed');

                if (stationId === 'sorting_machine') {
                    const isBuildZone0 = dropTarget.id === 'build-zone-0';
                    const isBuildZone1 = dropTarget.id === 'build-zone-1';
                    
                    if ((isBuildZone0 && partType === 'and') || (isBuildZone1 && partType === 'not')) {
                        const placedGateContainer = document.getElementById(isBuildZone0 ? 'placed-gate-build-0' : 'placed-gate-build-1');
                        if (placedGateContainer) {
                            placedGateContainer.innerHTML = gateSymbols[partType];
                            placedGateContainer.style.visibility = 'visible';
                        }
                        dropTarget.id += '-filled';
                        
                        const andPlaced = document.getElementById('build-zone-0-filled');
                        const notPlaced = document.getElementById('build-zone-1-filled');
                        if (andPlaced && notPlaced) {
                            nandBuilt = true;
                            placedGateType = 'nand';
                            const discoveryText = pz.discovery;
                            if (discoveryText) {
                                const discoveryEl = document.getElementById('discovery-text');
                                discoveryEl.innerHTML = `<h2 class="font-bold text-purple-400">New Discovery!</h2><p>${discoveryText}</p>`;
                                discoveryEl.classList.remove('hidden');
                            }
                            updateCircuit();
                        }
                    } else {
                        part.style.display = 'block';
                        part.classList.remove('placed');
                    }

                } else {
                    placedGateType = partType;
                    const placedGateContainer = document.getElementById('placed-gate-0');
                    if (placedGateContainer) {
                        placedGateContainer.innerHTML = gateSymbols[partType];
                        placedGateContainer.style.visibility = 'visible';
                    }
                    dropTarget.id += '-filled';
                    document.getElementById('parts-bin').style.display = 'none';
                    updateCircuit();
                }
            };

            modalContentArea.querySelectorAll('.draggable-part').forEach((part) => {
                part.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (part.classList.contains('placed') || puzzleSolved) return;
                    const clone = part.cloneNode(true);
                    clone.classList.add('dragging');
                    document.body.appendChild(clone);
                    const moveClone = (moveEvent) => {
                        clone.style.left = `${moveEvent.clientX - 45}px`;
                        clone.style.top = `${moveEvent.clientY - 25}px`;
                    };
                    moveClone(e);
                    const drop = (upEvent) => {
                        clone.remove();
                        const dropTarget = document.elementFromPoint(upEvent.clientX, upEvent.clientY);
                        if (dropTarget && dropTarget.classList.contains('drop-zone') && !dropTarget.id.includes('filled')) {
                            dropHandler(part, dropTarget);
                        }
                        document.removeEventListener('mousemove', moveClone);
                        document.removeEventListener('mouseup', drop, { once: true });
                    };
                    document.addEventListener('mousemove', moveClone);
                    document.addEventListener('mouseup', drop, { once: true });
                });
            });

            ['A', 'B'].forEach((char, index) => {
                const control = document.getElementById(`control-${char}`);
                if (control) {
                    control.addEventListener('click', () => {
                        inputs[index] = inputs[index] === 0 ? 1 : 0;
                        control.textContent = inputs[index];
                        control.classList.toggle('on');
                        control.classList.toggle('off');
                        updateCircuit();
                    });
                }
            });
            
            updateCircuit();
        }

        // --- Drawing & Game Loop ---
        function checkCollision(r1, r2) { return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y; }
        function drawSprite(sprite, x, y, scale, baseColor) {
            const colors = [...sprite.colors];
            if (baseColor) colors[1] = baseColor;
            for (let r = 0; r < sprite.height; r++) for (let col = 0; col < sprite.width; col++) {
                const index = parseInt(sprite.data[r][col]);
                if (index !== 0 && colors[index]) {
                    ctx.fillStyle = colors[index];
                    ctx.fillRect(x + col * scale, y + r * scale, scale, scale);
                }
            }
        }

        function drawWorld() {
            for (let y = 0; y < canvas.height; y += TILE_SIZE) for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                ctx.fillStyle = ((x / TILE_SIZE) % 2 === (y / TILE_SIZE) % 2) ? palette.floor_dark : palette.floor_light;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
            
            if (!floorIsComplete) {
                const activeStationId = puzzleSequence[currentPuzzleIndex];
                const activeStation = worldObjects.find(obj => obj.id === activeStationId);
                if (activeStation) {
                    ctx.fillStyle = 'rgba(253, 224, 71, 0.3)';
                    ctx.beginPath();
                    ctx.arc(activeStation.x + activeStation.width / 2, activeStation.y + activeStation.height / 2, 60, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            worldObjects.forEach(obj => {
                if (obj.type === 'station') {
                    const isCompleted = puzzleState[obj.id].completed;
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE, isCompleted ? obj.onColor : obj.color);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                    if (isCompleted) {
                        ctx.fillStyle = '#4ade80';
                        ctx.font = 'bold 24px "Roboto Mono"';
                        ctx.fillText('✓', obj.x + obj.width / 2, obj.y - 10);
                    }
                } else if (obj.type === 'stairs') {
                    drawSprite(obj.sprite, obj.x, obj.y, PIXEL_SCALE);
                    ctx.fillStyle = (obj.direction === 'up' && floorIsComplete) || obj.direction === 'down' ? '#a3e635' : '#ffffff';
                    ctx.font = '12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x + obj.width / 2, obj.y + obj.height + 12);
                }
            });
        }
        function update() {
            let nextX = player.x, nextY = player.y;
            if (keys.ArrowUp) nextY -= player.speed;
            if (keys.ArrowDown) nextY += player.speed;
            if (keys.ArrowLeft) nextX -= player.speed;
            if (keys.ArrowRight) nextX += player.speed;
            if (nextX < 0) nextX = 0;
            if (nextX + player.width > canvas.width) nextX = canvas.width - player.width;
            if (nextY < 0) nextY = 0;
            if (nextY + player.height > canvas.height) nextY = canvas.height - player.height;
            
            player.x = nextX;
            player.y = nextY;
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            drawSprite(playerSprite, player.x, player.y, PIXEL_SCALE);
            let interactionTarget = worldObjects.find(obj => checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 }));
            if (interactionTarget) {
                ctx.fillStyle = 'white';
                ctx.font = '16px "Inter"';
                ctx.textAlign = 'center';
                ctx.fillText(`Press 'E' to interact with ${interactionTarget.name}`, canvas.width / 2, canvas.height - 30);
            }
        }
        function gameLoop() {
            if (modal.classList.contains('hidden')) update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        function handleInteraction(obj) {
            if (obj.type === 'stairs') {
                launchStairsModal(obj);
                return;
            }

            if (obj.type === 'station') {
                const targetStationIndex = puzzleSequence.indexOf(obj.id);
                if (targetStationIndex > currentPuzzleIndex) {
                    showMessage('Out of Sequence', 'This station is not active yet. Please find the highlighted station to proceed.');
                } else {
                    launchPuzzle(obj.id);
                }
            }
        }
        window.addEventListener('keydown', (e) => {
            if (modal.classList.contains('hidden')) {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'e') {
                    const interactionTarget = worldObjects.find(obj => checkCollision(player, { ...obj, x: obj.x - 10, y: obj.y - 10, width: obj.width + 20, height: obj.height + 20 }));
                    if(interactionTarget) handleInteraction(interactionTarget);
                }
            }
        });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        window.addEventListener('resize', initializeWorld);

        // --- Start the game! ---
        function startGame() {
            initializeWorld();
            const introText = "Welcome to the Repair Bay. A few machines are on the fritz and it's your job to fix them. Walk up to a highlighted station and press 'E' to see the problem. You'll need to choose the right logic gate for the job. Good luck!";
            showMessage("Welcome to the Repair Bay!", introText, gameLoop);
        }
        startGame();
    </script>
</body>
</html>


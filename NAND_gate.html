<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How a NAND Gate Works - Interactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            touch-action: none;
        }
        .puzzle-container {
            background-color: #0f172a;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid #38bdf8;
            width: 95%;
            max-width: 700px;
            text-align: center;
        }
        .circuit-bg { background-color: #1e293b; }

        .bit-display {
            width: 60px; height: 60px; border-radius: 0.5rem; border: 4px solid #475569;
            font-family: 'Roboto Mono', monospace; font-size: 1.8rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease-in-out;
            cursor: pointer; user-select: none;
        }
        .bit-display.input.off, .bit-display.output.off { background-color: #475569; color: #f43f5e; }
        .bit-display.input.on, .bit-display.output.on { background-color: #1e293b; color: #4ade80; border-color: #4ade80; }

        .circuit-line { stroke: #475569; stroke-width: 6; stroke-linecap: round; transition: stroke 0.3s, filter 0.3s; }
        .circuit-line.powered { stroke: #facc15; filter: drop-shadow(0 0 4px #facc15); }
        .circuit-line.control-powered { stroke: #4ade80; filter: drop-shadow(0 0 4px #4ade80); }
        .circuit-text { font-family: 'Roboto Mono', monospace; fill: #94a3b8; font-size: 14px; user-select: none;}
        
        .gate-symbol-draggable { fill: #38bdf8; }
        .gate-text-draggable { font-size: 14px; font-weight: bold; fill: white; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        
        .draggable-part { cursor: grab; }
        .draggable-part.dragging { cursor: grabbing; opacity: 0.5; }
        .drop-zone { fill: rgba(139, 92, 246, 0.2); stroke: #a78bfa; stroke-width: 2; stroke-dasharray: 4; transition: fill 0.2s; }
        .drop-zone.correct { fill: rgba(74, 222, 128, 0.2); stroke: #4ade80; }
        .drop-zone.incorrect { fill: rgba(244, 63, 94, 0.2); stroke: #f43f5e; }
        
        .truth-table th, .truth-table td {
            border: 1px solid #475569; padding: 0.5rem; text-align: center;
            font-family: 'Roboto Mono', monospace; color: #cbd5e1; font-size: 1.125rem;
        }
        .truth-table th { background-color: #334155; }
        .truth-table tr.discovered { color: #86efac; font-weight: bold; }

        .touch-drag-clone {
            position: absolute;
            pointer-events: none;
            z-index: 50;
            opacity: 0.7;
        }
        .placed-gate-svg {
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="puzzle-container" class="puzzle-container">
        <!-- Content will be injected by JavaScript -->
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Game State ---
            const puzzleState = {
                mode: 'build',
                title: 'Building a NAND Gate',
                buildText: "A NAND gate is an 'AND-NOT' gate. Its output is the opposite of an AND gate. Build one by dragging the logic gates into the circuit slots.",
                testText: "The circuit is complete. Now, test the inputs to see how it behaves. If you've built a NAND gate correctly, the 'Station Complete' button will appear after you test all four combinations.",
                truthTable: {},
                discoveredCombinations: new Set(),
            };
            
            const gateLogic = {
                AND: (a, b) => a && b,
                OR: (a, b) => a || b,
                NOT: (a) => !a,
            };

            // --- SVG and HTML Templates ---
            const gatePartsSvg = `
                <div id="draggable-and" class="draggable-part" data-gate-type="AND" draggable="true">
                    <svg viewBox="0 0 60 40" class="w-20 h-14"><path d="M10 5 H30 C 45 5, 45 35, 30 35 H10 Z" class="gate-symbol-draggable" /><text x="26" y="20" class="gate-text-draggable">AND</text></svg>
                </div>
                <div id="draggable-not" class="draggable-part" data-gate-type="NOT" draggable="true">
                    <svg viewBox="0 0 60 40" class="w-20 h-14"><path d="M10 5 L40 20 L10 35 Z" class="gate-symbol-draggable"/><circle cx="45" cy="20" r="4" stroke-width="2" stroke="#38bdf8" fill="none"/><text x="23" y="20" class="gate-text-draggable">NOT</text></svg>
                </div>
                <div id="draggable-or" class="draggable-part" data-gate-type="OR" draggable="true">
                    <svg viewBox="0 0 60 40" class="w-20 h-14"><path d="M10 5 C 20 5, 30 10, 40 20 C 30 30, 20 35, 10 35 Q 25 20, 10 5 Z" class="gate-symbol-draggable"/><text x="28" y="20" class="gate-text-draggable">OR</text></svg>
                </div>
            `;

            const nandCircuitSchematic = `
                <svg viewBox="0 0 600 300" class="w-full">
                    <!-- Inputs -->
                    <path id="line-a-in" d="M50 80 h50" class="circuit-line" />
                    <path id="line-b-in" d="M50 160 h50" class="circuit-line" />
                    
                    <!-- First Gate Slot -->
                    <path d="M100 80 v40" class="circuit-line" />
                    <path d="M100 160 v-40" class="circuit-line" />
                    <g id="slot-1" class="drop-target-group" data-expected-gate="AND">
                        <rect class="drop-zone" x="100" y="70" width="100" height="100" rx="5" />
                        <g class="placed-gate-container"></g>
                    </g>
                    
                    <!-- Intermediate Line -->
                    <path id="line-mid" d="M200 120 h50" class="circuit-line" />
                    
                    <!-- Second Gate Slot -->
                    <g id="slot-2" class="drop-target-group" data-expected-gate="NOT">
                        <rect class="drop-zone" x="250" y="95" width="100" height="50" rx="5" />
                        <g class="placed-gate-container"></g>
                    </g>

                    <!-- Output Line -->
                    <path id="line-out" d="M350 120 h50" class="circuit-line" />

                    <!-- Input/Output Displays -->
                    <foreignObject x="10" y="50" width="70" height="60"><div xmlns="http://www.w3.org/1999/xhtml" id="input-a-wrapper" class="flex items-center justify-center h-full"><div id="input-a-signal" class="bit-display input off">0</div></div></foreignObject>
                    <text x="45" y="125" class="circuit-text" text-anchor="middle">Input A</text>
                    
                    <foreignObject x="10" y="130" width="70" height="60"><div xmlns="http://www.w3.org/1999/xhtml" id="input-b-wrapper" class="flex items-center justify-center h-full"><div id="input-b-signal" class="bit-display input off">0</div></div></foreignObject>
                    <text x="45" y="205" class="circuit-text" text-anchor="middle">Input B</text>

                    <foreignObject x="410" y="90" width="70" height="60"><div xmlns="http://www.w3.org/1999/xhtml" class="flex items-center justify-center h-full"><div id="output-display" class="bit-display output off">0</div></div></foreignObject>
                    <text x="445" y="165" class="circuit-text" text-anchor="middle">Output</text>
                </svg>`;

            function setupPuzzle() {
                const container = document.getElementById('puzzle-container');
                container.innerHTML = `
                    <div id="instruction-text" class="text-center mb-6">
                        <h1 class="text-3xl font-bold text-white">${puzzleState.title}</h1>
                        <p class="text-slate-400 max-w-3xl mx-auto">${puzzleState.buildText}</p>
                    </div>
                    <div class="circuit-bg p-4 sm:p-8 rounded-lg shadow-2xl">
                        <div class="flex flex-col items-center gap-8">
                            <div id="parts-bin-wrapper" class="h-20 flex justify-center items-center">
                                <div id="parts-bin" class="flex gap-4">${gatePartsSvg}</div>
                            </div>
                            <div id="schematic-area" class="w-full">${nandCircuitSchematic}</div>
                            <div id="truth-table-container" class="w-full mt-4"></div>
                        </div>
                        <div class="mt-6 text-right h-10">
                            <button id="puzzle-complete-btn" class="hidden bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded">Station Complete!</button>
                        </div>
                    </div>`;
                
                document.getElementById('input-a-wrapper').style.display = 'none';
                document.getElementById('input-b-wrapper').style.display = 'none';
                
                setupBuildMode();
                updateTruthTable();
            }

            function setupBuildMode() {
                let draggedItem = null;
                let touchDragClone = null;

                function handleDrop(slotElement, gateElement) {
                    if (slotElement.dataset.gatePlaced) return;

                    const gateType = gateElement.dataset.gateType;
                    const expectedType = slotElement.dataset.expectedGate;
                    const isCorrect = gateType === expectedType;
                    
                    const placedGateSVG = gateElement.querySelector('svg').cloneNode(true);
                    placedGateSVG.classList.add('placed-gate-svg');
                    const slotRect = slotElement.querySelector('.drop-zone').getBBox();
                    
                    const svgWidth = 80;
                    const svgHeight = 56;
                    placedGateSVG.setAttribute('width', svgWidth);
                    placedGateSVG.setAttribute('height', svgHeight);
                    placedGateSVG.setAttribute('x', slotRect.x + (slotRect.width - svgWidth) / 2);
                    placedGateSVG.setAttribute('y', slotRect.y + (slotRect.height - svgHeight) / 2);
                    
                    slotElement.querySelector('.placed-gate-container').appendChild(placedGateSVG);
                    gateElement.style.visibility = 'hidden';
                    
                    slotElement.dataset.gatePlaced = gateType;
                    const dropZone = slotElement.querySelector('.drop-zone');
                    dropZone.classList.add(isCorrect ? 'correct' : 'incorrect');
                    
                    if (document.getElementById('slot-1').dataset.gatePlaced && document.getElementById('slot-2').dataset.gatePlaced) {
                        switchToTestMode();
                    }
                }

                document.querySelectorAll('.draggable-part').forEach(part => {
                    part.addEventListener('dragstart', e => {
                        draggedItem = part;
                        setTimeout(() => part.classList.add('dragging'), 0);
                    });
                    part.addEventListener('dragend', () => {
                        if(draggedItem) {
                           draggedItem.classList.remove('dragging');
                           draggedItem = null;
                        }
                    });
                    part.addEventListener('touchstart', e => {
                        e.preventDefault();
                        draggedItem = part;
                        touchDragClone = part.cloneNode(true);
                        touchDragClone.classList.add('touch-drag-clone');
                        document.body.appendChild(touchDragClone);
                        updateClonePosition(e.touches[0]);
                    }, { passive: false });
                });

                document.querySelectorAll('.drop-target-group').forEach(slot => {
                    slot.addEventListener('dragover', e => e.preventDefault());
                    slot.addEventListener('drop', e => {
                        e.preventDefault();
                        if (draggedItem) {
                            handleDrop(slot, draggedItem);
                        }
                    });
                });

                document.body.addEventListener('touchmove', e => {
                    if (!draggedItem || !touchDragClone) return;
                    e.preventDefault();
                    updateClonePosition(e.touches[0]);
                }, { passive: false });

                document.body.addEventListener('touchend', e => {
                    if (!draggedItem || !touchDragClone) return;
                    
                    touchDragClone.style.display = 'none';
                    const touch = e.changedTouches[0];
                    const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.drop-target-group');
                    
                    if (dropTarget) {
                        handleDrop(dropTarget, draggedItem);
                    }

                    document.body.removeChild(touchDragClone);
                    touchDragClone = null;
                    draggedItem = null;
                });

                function updateClonePosition(touch) {
                    touchDragClone.style.left = `${touch.clientX - touchDragClone.offsetWidth / 2}px`;
                    touchDragClone.style.top = `${touch.clientY - touchDragClone.offsetHeight / 2}px`;
                }
            }
            
            function switchToTestMode() {
                puzzleState.mode = 'test';
                document.querySelector('#instruction-text p').innerHTML = puzzleState.testText;
                document.getElementById('parts-bin-wrapper').classList.add('hidden');
                document.getElementById('input-a-wrapper').style.display = 'flex';
                document.getElementById('input-b-wrapper').style.display = 'flex';
                setupTestLogic();
            }

            function setupTestLogic() {
                const inputA = document.getElementById('input-a-signal');
                const inputB = document.getElementById('input-b-signal');
                let isInputA_On = false;
                let isInputB_On = false;

                const updateCircuit = () => {
                    const gate1Type = document.getElementById('slot-1').dataset.gatePlaced;
                    const gate2Type = document.getElementById('slot-2').dataset.gatePlaced;

                    let midResult = false;
                    if (gate1Type && gateLogic[gate1Type]) {
                        midResult = gateLogic[gate1Type](isInputA_On, isInputB_On);
                    }

                    let finalResult = midResult;
                    if (gate2Type && gateLogic[gate2Type] && gate2Type === 'NOT') {
                        finalResult = gateLogic[gate2Type](midResult);
                    } else if (gate2Type) {
                        // If a non-NOT gate is in slot 2, it doesn't connect right, so output is false.
                        finalResult = false;
                    }

                    inputA.textContent = isInputA_On ? '1' : '0';
                    inputA.classList.toggle('on', isInputA_On);
                    inputB.textContent = isInputB_On ? '1' : '0';
                    inputB.classList.toggle('on', isInputB_On);
                    document.getElementById('output-display').textContent = finalResult ? '1' : '0';
                    document.getElementById('output-display').classList.toggle('on', finalResult);

                    document.getElementById('line-a-in').classList.toggle('control-powered', isInputA_On);
                    document.getElementById('line-b-in').classList.toggle('control-powered', isInputB_On);
                    document.getElementById('line-mid').classList.toggle('powered', midResult);
                    document.getElementById('line-out').classList.toggle('powered', finalResult);
                    
                    const inputKey = `${isInputA_On ? '1' : '0'}${isInputB_On ? '1' : '0'}`;
                    
                    if(puzzleState.discoveredCombinations.has(inputKey)) return;

                    puzzleState.truthTable[inputKey] = finalResult ? '1' : '0';
                    puzzleState.discoveredCombinations.add(inputKey);
                    updateTruthTable();

                    const isNandGate = gate1Type === 'AND' && gate2Type === 'NOT';
                    if (isNandGate && puzzleState.discoveredCombinations.size === 4) {
                        document.getElementById('puzzle-complete-btn').classList.remove('hidden');
                    }
                };

                inputA.addEventListener('click', () => { isInputA_On = !isInputA_On; updateCircuit(); });
                inputB.addEventListener('click', () => { isInputB_On = !isInputB_On; updateCircuit(); });
                
                updateCircuit();
            }

            function updateTruthTable() {
                const container = document.getElementById('truth-table-container');
                const combinations = ['00', '01', '10', '11'];
                let rows = '';

                for (const combo of combinations) {
                    const discovered = puzzleState.discoveredCombinations.has(combo);
                    const output = discovered ? puzzleState.truthTable[combo] : '?';
                    const [inputA, inputB] = combo.split('');
                    rows += `<tr class="${discovered ? 'discovered' : ''}"><td>${inputA}</td><td>${inputB}</td><td>${output}</td></tr>`;
                }
                
                container.innerHTML = `
                    <h2 class="text-xl font-bold text-white mb-2">Truth Table</h2>
                    <table class="truth-table mx-auto">
                        <thead><tr><th>Input A</th><th>Input B</th><th>Output</th></tr></thead>
                        <tbody>${rows}</tbody>
                    </table>`;
            }

            setupPuzzle();
        });
    </script>
</body>
</html>

